// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: arc/arc.proto

// package arc is an implementation-independent API and support for a distributed
// files, media, and communication system running a realtime 2D/3D/XR client.

package arc

import (
	bytes "bytes"
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Const int32

const (
	Const_Defs Const = 0
	// HostSessionCellID is a hard-coded cell ID for the user's session
	// This is the first cell pinned as it allows the host and client to exchange MsgOp_ResolveAndRegister msgs.
	Const_HostSessionCellID Const = 3
	// RootCellID is a hard-coded cell ID used to pin the root cell for a user.
	Const_RootCellID Const = 6
	// TIDBinaryLen is the byte size of a Tx ID ("TID"), a hash with a leading big endian binary time index.
	//
	// This allows TIDs to be naturally sorted chronologically naturally.
	// This facilitates Tx storage and Tx syndication (time-ordered Tx playback).  This also improves performance.
	// since most operations tend to be in the same time neighborhood, leveraging the db's cache.
	//
	// Byte layout is designed so that TIDs are sortable by their embedded timestamp:
	//    0:6   - Standard UTC timestamp in unix seconds (big endian)
	//    6:8   - Timestamp fraction (big endian)
	//    8:30  - Signature/hash
	Const_TIDBinaryLen Const = 30
	// TIDStringLen is the ASCII-compatible string length of a (binary) TID encoded into its base32 form.
	// The encoding used is the geohash base32 alphabet, so that even ascii ordinal string comparisons will correctly sort encoded TIDs by time.
	Const_TIDStringLen Const = 48
	// TIDTimestampSz is the number of left-hand bytes in a TID reserved for a time index value.
	Const_TIDTimestampSz Const = 8
	// DefaultGrpcServicePort is the TCP port the service HostGrpc should run on by default.
	Const_DefaultGrpcServicePort Const = 5192
)

var Const_name = map[int32]string{
	0:    "Const_Defs",
	3:    "Const_HostSessionCellID",
	6:    "Const_RootCellID",
	30:   "Const_TIDBinaryLen",
	48:   "Const_TIDStringLen",
	8:    "Const_TIDTimestampSz",
	5192: "Const_DefaultGrpcServicePort",
}

var Const_value = map[string]int32{
	"Const_Defs":                   0,
	"Const_HostSessionCellID":      3,
	"Const_RootCellID":             6,
	"Const_TIDBinaryLen":           30,
	"Const_TIDStringLen":           48,
	"Const_TIDTimestampSz":         8,
	"Const_DefaultGrpcServicePort": 5192,
}

func (Const) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{0}
}

// ValType describes the type of a Cell, an Attr literal, or Attr set collection element type.
type ValType int32

const (
	ValType_nil         ValType = 0
	ValType_int         ValType = 4
	ValType_bytes       ValType = 6
	ValType_string      ValType = 7
	ValType_TID         ValType = 16
	ValType_SchemaID    ValType = 18
	ValType_Blob        ValType = 22
	ValType_DateTime    ValType = 23
	ValType_Duration    ValType = 24
	ValType_AssetURI    ValType = 25
	ValType_URL         ValType = 26
	ValType_Err         ValType = 50
	ValType_DataSegment ValType = 52
	ValType_Content     ValType = 54
	ValType_CryptoKey   ValType = 56
	ValType_Txn         ValType = 58
	ValType_LoginReq    ValType = 60
	ValType_Defs        ValType = 62
	ValType_PinReq      ValType = 64
	ValType_AttrRange   ValType = 66
	ValType_Link        ValType = 80
	ValType_GeoFix      ValType = 82
	ValType_TRS         ValType = 84
	// Clients have above this value to bind their own ValTypeIDs
	ValType_BuiltinMax ValType = 999
)

var ValType_name = map[int32]string{
	0:   "ValType_nil",
	4:   "ValType_int",
	6:   "ValType_bytes",
	7:   "ValType_string",
	16:  "ValType_TID",
	18:  "ValType_SchemaID",
	22:  "ValType_Blob",
	23:  "ValType_DateTime",
	24:  "ValType_Duration",
	25:  "ValType_AssetURI",
	26:  "ValType_URL",
	50:  "ValType_Err",
	52:  "ValType_DataSegment",
	54:  "ValType_Content",
	56:  "ValType_CryptoKey",
	58:  "ValType_Txn",
	60:  "ValType_LoginReq",
	62:  "ValType_Defs",
	64:  "ValType_PinReq",
	66:  "ValType_AttrRange",
	80:  "ValType_Link",
	82:  "ValType_GeoFix",
	84:  "ValType_TRS",
	999: "ValType_BuiltinMax",
}

var ValType_value = map[string]int32{
	"ValType_nil":         0,
	"ValType_int":         4,
	"ValType_bytes":       6,
	"ValType_string":      7,
	"ValType_TID":         16,
	"ValType_SchemaID":    18,
	"ValType_Blob":        22,
	"ValType_DateTime":    23,
	"ValType_Duration":    24,
	"ValType_AssetURI":    25,
	"ValType_URL":         26,
	"ValType_Err":         50,
	"ValType_DataSegment": 52,
	"ValType_Content":     54,
	"ValType_CryptoKey":   56,
	"ValType_Txn":         58,
	"ValType_LoginReq":    60,
	"ValType_Defs":        62,
	"ValType_PinReq":      64,
	"ValType_AttrRange":   66,
	"ValType_Link":        80,
	"ValType_GeoFix":      82,
	"ValType_TRS":         84,
	"ValType_BuiltinMax":  999,
}

func (ValType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{1}
}

// MsgOp tells a holder of a Msg how to interpret its purpose and fields.
type MsgOp int32

const (
	MsgOp_NoOp MsgOp = 0
	// From the client to host, this requests to login to the host.
	// From the host to client, this is a reply with a challenge.
	//
	// Params:
	//      Msg.ReqID:        client-generated (unique) request ID
	//      Msg.ValType:      ValType_LoginReq
	//      Msg.ValBuf:       req params
	MsgOp_Login MsgOp = 1
	// MsgOp_ResolveAndRegister allows a client to send the host a set of Defs to the Host, defining all session CellTypes and identifiers.
	//
	// Params:
	//      Msg.ReqID:      client-generated (unique) request ID
	//      Msg.ValType:    ValType_Defs
	//      Msg.ValBuf:     Defs (serialized)
	MsgOp_ResolveAndRegister MsgOp = 5
	// From client to host, this requests a given cell be pinned.
	// From host to client, this is precedes a push of the pinned cell's attributes.
	// Note that the same cell pinned multiple times may not have child cells with matching cell IDs.
	//
	// Params:
	//      Msg.ReqID:      client-generated (unique) request ID
	//      Msg.CellID:     CellID being pinned     (host to client, otherwise 0)
	//      Msg.ValType:    ValType_PinReq          (client to host, otherwise nil)
	//      Msg.ValBuf:     PinReq                  (client to host, otherwise nil)
	MsgOp_PinCell MsgOp = 6
	// Used to push attr values.
	// A cell attr item us specified by the host via ReqID+AttrID+SI and its value type via ValType.
	//
	// Params:
	//      Msg.ReqID:      originating request ID
	//      Msg.CellID:     which cell is being updated
	//      Msg.AttrID:     which attr is being updated
	//      Msg.ValType:    format of Msg.ValInt / .ValBuf
	//      Msg.Val*:       attr value
	MsgOp_PushAttr MsgOp = 10
	// This MsgOp signals the insertion of a new cell.
	// The new cell is either as a child cell or the "content" of the cell being pinned (detected via Msg.CellID == MsgOp_PinCell.CellID).
	// After this message, zero or more MsgOp_PushAttr msgs follow.
	//
	// Params:
	//      Msg.ReqID:      originating request ID
	//      Msg.CellID:     new cell being added
	//      Msg.ValType:    ValType_SchemaID
	//      Msg.ValInt:     cell schema ID being pushed (specifies which Cell attribs are expected to follow)
	MsgOp_InsertCell MsgOp = 14
	// Used by the Host to signal that the request associated with ReqID is up to date and in a state to be processed by the client.
	// This msg is typically used to drive UI updates or other aggregate cell dependencies.
	//
	// Params:
	//      Msg.ReqID:      originating request ID
	//      Msg.CellID:     which cell is an an updated state
	MsgOp_Commit MsgOp = 24
	// From the client to host, this signals to cancel the operation(s) associated with the given request ID (PinID).
	// From the host to client, this signals that the given request ID has been canceled / discarded (and is now closed).
	// if Msg.ValType == ValType_Err, amplifying info in included as to why the request was closed.
	//
	// Params:
	//      Msg.ReqID:      parent request ID
	//      Msg.ValType:    ValType_Err (or 0)
	MsgOp_CloseReq MsgOp = 255
)

var MsgOp_name = map[int32]string{
	0:   "MsgOp_NoOp",
	1:   "MsgOp_Login",
	5:   "MsgOp_ResolveAndRegister",
	6:   "MsgOp_PinCell",
	10:  "MsgOp_PushAttr",
	14:  "MsgOp_InsertCell",
	24:  "MsgOp_Commit",
	255: "MsgOp_CloseReq",
}

var MsgOp_value = map[string]int32{
	"MsgOp_NoOp":               0,
	"MsgOp_Login":              1,
	"MsgOp_ResolveAndRegister": 5,
	"MsgOp_PinCell":            6,
	"MsgOp_PushAttr":           10,
	"MsgOp_InsertCell":         14,
	"MsgOp_Commit":             24,
	"MsgOp_CloseReq":           255,
}

func (MsgOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{2}
}

type MsgFlags int32

const (
	MsgFlags_None MsgFlags = 0
	// CellCheckpoint signals that the cell referenced by this Msg is at a stable state "checkpoint",
	MsgFlags_CellCheckpoint MsgFlags = 1
	// ValBufShared signals that this Msg's ValBuf referenced elsewhere and is therefore READ ONLY.
	// This used internally to support Msg pooling / recycling.
	// When marshaling, this flag is always cleared!
	MsgFlags_ValBufShared MsgFlags = 256
)

var MsgFlags_name = map[int32]string{
	0:   "MsgFlags_None",
	1:   "MsgFlags_CellCheckpoint",
	256: "MsgFlags_ValBufShared",
}

var MsgFlags_value = map[string]int32{
	"MsgFlags_None":           0,
	"MsgFlags_CellCheckpoint": 1,
	"MsgFlags_ValBufShared":   256,
}

func (MsgFlags) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{3}
}

// Note that element domain uniqueness always implies an SI *and* a FromID.
type SeriesType int32

const (
	// SeriesType_Fixed denotes that a given data model attr URI is bound to a given AttrID and SeriesIndex assignment.
	// AttrSpec.Fixed_SI is used in conjunction with this, allowing the client to wire multiple data model attrs to the same AttrID.
	SeriesType_Fixed SeriesType = 0
	// SeriesType_I64 denotes that SI values are int64
	SeriesType_I64 SeriesType = 2
	// SeriesType_Time16 denotes that SI values are signed 48.16 bit time offsets (1 second == 2^16 ticks).
	SeriesType_Time16 SeriesType = 5
	// SeriesType_UTC16 denotes that SI values are signed 48.16 bit UTC values (1 second == 2^16 ticks).
	SeriesType_UTC16 SeriesType = 6
)

var SeriesType_name = map[int32]string{
	0: "SeriesType_Fixed",
	2: "SeriesType_I64",
	5: "SeriesType_Time16",
	6: "SeriesType_UTC16",
}

var SeriesType_value = map[string]int32{
	"SeriesType_Fixed":  0,
	"SeriesType_I64":    2,
	"SeriesType_Time16": 5,
	"SeriesType_UTC16":  6,
}

func (SeriesType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{4}
}

type GeoModel int32

const (
	GeoModel_Sphere GeoModel = 0
)

var GeoModel_name = map[int32]string{
	0: "GeoModel_Sphere",
}

var GeoModel_value = map[string]int32{
	"GeoModel_Sphere": 0,
}

func (GeoModel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{5}
}

// CryptoKitID identifies an encryption suite that implements ski.CryptoKit
type CryptoKitID int32

const (
	CryptoKit_Nil             CryptoKitID = 0
	CryptoKit_SecretBox_NaCl  CryptoKitID = 100
	CryptoKit_AsymMsg_NaCl    CryptoKitID = 101
	CryptoKit_Signing_NaCl    CryptoKitID = 102
	CryptoKit_Signing_ED25519 CryptoKitID = 202
)

var CryptoKitID_name = map[int32]string{
	0:   "CryptoKit_Nil",
	100: "CryptoKit_SecretBox_NaCl",
	101: "CryptoKit_AsymMsg_NaCl",
	102: "CryptoKit_Signing_NaCl",
	202: "CryptoKit_Signing_ED25519",
}

var CryptoKitID_value = map[string]int32{
	"CryptoKit_Nil":             0,
	"CryptoKit_SecretBox_NaCl":  100,
	"CryptoKit_AsymMsg_NaCl":    101,
	"CryptoKit_Signing_NaCl":    102,
	"CryptoKit_Signing_ED25519": 202,
}

func (CryptoKitID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{6}
}

// ErrCode expresses status and error codes.
type ErrCode int32

const (
	ErrCode_NoErr                   ErrCode = 0
	ErrCode_UnnamedErr              ErrCode = 5000
	ErrCode_InternalErr             ErrCode = 5001
	ErrCode_UnsupportedOp           ErrCode = 5002
	ErrCode_Unimplemented           ErrCode = 5003
	ErrCode_ReqCanceled             ErrCode = 5004
	ErrCode_ShuttingDown            ErrCode = 5005
	ErrCode_Disconnected            ErrCode = 5006
	ErrCode_InvalidLogin            ErrCode = 5007
	ErrCode_ReqNotFound             ErrCode = 5010
	ErrCode_InvalidReq              ErrCode = 5020
	ErrCode_InvalidURI              ErrCode = 5021
	ErrCode_BadValue                ErrCode = 5022
	ErrCode_NothingToCommit         ErrCode = 5030
	ErrCode_CommitFailed            ErrCode = 5031
	ErrCode_PlanetNotFound          ErrCode = 5032
	ErrCode_PlanetFailure           ErrCode = 5033
	ErrCode_AppNotFound             ErrCode = 5034
	ErrCode_NoAttrsFound            ErrCode = 5036
	ErrCode_MalformedTx             ErrCode = 5040
	ErrCode_TypeNotFound            ErrCode = 5050
	ErrCode_TypeNotRegistered       ErrCode = 5051
	ErrCode_BadSchema               ErrCode = 5052
	ErrCode_DataFailure             ErrCode = 5053
	ErrCode_InvalidCell             ErrCode = 5055
	ErrCode_NotPinnable             ErrCode = 5056
	ErrCode_ViolatesAppendOnly      ErrCode = 5100
	ErrCode_InsufficientPermissions ErrCode = 5101
	ErrCode_ChProtocolNotRecognized ErrCode = 5201
)

var ErrCode_name = map[int32]string{
	0:    "ErrCode_NoErr",
	5000: "ErrCode_UnnamedErr",
	5001: "ErrCode_InternalErr",
	5002: "ErrCode_UnsupportedOp",
	5003: "ErrCode_Unimplemented",
	5004: "ErrCode_ReqCanceled",
	5005: "ErrCode_ShuttingDown",
	5006: "ErrCode_Disconnected",
	5007: "ErrCode_InvalidLogin",
	5010: "ErrCode_ReqNotFound",
	5020: "ErrCode_InvalidReq",
	5021: "ErrCode_InvalidURI",
	5022: "ErrCode_BadValue",
	5030: "ErrCode_NothingToCommit",
	5031: "ErrCode_CommitFailed",
	5032: "ErrCode_PlanetNotFound",
	5033: "ErrCode_PlanetFailure",
	5034: "ErrCode_AppNotFound",
	5036: "ErrCode_NoAttrsFound",
	5040: "ErrCode_MalformedTx",
	5050: "ErrCode_TypeNotFound",
	5051: "ErrCode_TypeNotRegistered",
	5052: "ErrCode_BadSchema",
	5053: "ErrCode_DataFailure",
	5055: "ErrCode_InvalidCell",
	5056: "ErrCode_NotPinnable",
	5100: "ErrCode_ViolatesAppendOnly",
	5101: "ErrCode_InsufficientPermissions",
	5201: "ErrCode_ChProtocolNotRecognized",
}

var ErrCode_value = map[string]int32{
	"ErrCode_NoErr":                   0,
	"ErrCode_UnnamedErr":              5000,
	"ErrCode_InternalErr":             5001,
	"ErrCode_UnsupportedOp":           5002,
	"ErrCode_Unimplemented":           5003,
	"ErrCode_ReqCanceled":             5004,
	"ErrCode_ShuttingDown":            5005,
	"ErrCode_Disconnected":            5006,
	"ErrCode_InvalidLogin":            5007,
	"ErrCode_ReqNotFound":             5010,
	"ErrCode_InvalidReq":              5020,
	"ErrCode_InvalidURI":              5021,
	"ErrCode_BadValue":                5022,
	"ErrCode_NothingToCommit":         5030,
	"ErrCode_CommitFailed":            5031,
	"ErrCode_PlanetNotFound":          5032,
	"ErrCode_PlanetFailure":           5033,
	"ErrCode_AppNotFound":             5034,
	"ErrCode_NoAttrsFound":            5036,
	"ErrCode_MalformedTx":             5040,
	"ErrCode_TypeNotFound":            5050,
	"ErrCode_TypeNotRegistered":       5051,
	"ErrCode_BadSchema":               5052,
	"ErrCode_DataFailure":             5053,
	"ErrCode_InvalidCell":             5055,
	"ErrCode_NotPinnable":             5056,
	"ErrCode_ViolatesAppendOnly":      5100,
	"ErrCode_InsufficientPermissions": 5101,
	"ErrCode_ChProtocolNotRecognized": 5201,
}

func (ErrCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{7}
}

type TRS_VisualScaleMode int32

const (
	AutoScale  TRS_VisualScaleMode = 0
	FixedScale TRS_VisualScaleMode = 1
)

var TRS_VisualScaleMode_name = map[int32]string{
	0: "AutoScale",
	1: "FixedScale",
}

var TRS_VisualScaleMode_value = map[string]int32{
	"AutoScale":  0,
	"FixedScale": 1,
}

func (TRS_VisualScaleMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{15, 0}
}

type Msg struct {
	// Describes how this Msg should be interpreted
	Op MsgOp `protobuf:"varint,1,opt,name=Op,proto3,enum=arc.MsgOp" json:"Op,omitempty"`
	// ReqID specifies a request context.
	//
	// When a client issues request-side MsgOp (e.g. PinCell, ResolveAndRegister), ReqID specifies a new and uniquely generated ID that is used in subsequent Msgs.
	// If this msg is a reply to a request, ReqID identifies the originating request op.
	ReqID uint64 `protobuf:"varint,3,opt,name=ReqID,proto3" json:"ReqID,omitempty"`
	// CellID identifies the cell associated with Msg.Op.
	CellID uint64 `protobuf:"varint,6,opt,name=CellID,proto3" json:"CellID,omitempty"`
	FromID uint64 `protobuf:"varint,11,opt,name=FromID,proto3" json:"FromID,omitempty"`
	AttrID int32  `protobuf:"varint,15,opt,name=AttrID,proto3" json:"AttrID,omitempty"`
	// SI ("Series Index") associates and binds a value to and int64 key.
	// By convention, this is 48.16 fixed signed fractional seconds (one second == 0x10000 ticks), naming a time duration or timestamp.
	// When naming an absolute timestamp, unix UTC is assumed (0x10000 corresponds to 00:00:01, Jan 1 1970 GMT)
	SI int64 `protobuf:"varint,16,opt,name=SI,proto3" json:"SI,omitempty"`
	// ValType specifies how to interpret ValBuf / ValInt
	ValType ValType `protobuf:"varint,20,opt,name=ValType,proto3,enum=arc.ValType" json:"ValType,omitempty"`
	// ValBuf and/or ValInt are interpreted according to ValType
	ValBuf []byte `protobuf:"bytes,21,opt,name=ValBuf,proto3" json:"ValBuf,omitempty"`
	ValInt int64  `protobuf:"varint,22,opt,name=ValInt,proto3" json:"ValInt,omitempty"`
	// Flags contains MsgFlags
	Flags MsgFlags `protobuf:"varint,24,opt,name=Flags,proto3,enum=arc.MsgFlags" json:"Flags,omitempty"`
	// Allows a sequence of Msgs to be chained together.
	Next *Msg `protobuf:"bytes,32,opt,name=Next,proto3" json:"Next,omitempty"`
}

func (m *Msg) Reset()      { *m = Msg{} }
func (*Msg) ProtoMessage() {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{0}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

func (m *Msg) GetOp() MsgOp {
	if m != nil {
		return m.Op
	}
	return MsgOp_NoOp
}

func (m *Msg) GetReqID() uint64 {
	if m != nil {
		return m.ReqID
	}
	return 0
}

func (m *Msg) GetCellID() uint64 {
	if m != nil {
		return m.CellID
	}
	return 0
}

func (m *Msg) GetFromID() uint64 {
	if m != nil {
		return m.FromID
	}
	return 0
}

func (m *Msg) GetAttrID() int32 {
	if m != nil {
		return m.AttrID
	}
	return 0
}

func (m *Msg) GetSI() int64 {
	if m != nil {
		return m.SI
	}
	return 0
}

func (m *Msg) GetValType() ValType {
	if m != nil {
		return m.ValType
	}
	return ValType_nil
}

func (m *Msg) GetValBuf() []byte {
	if m != nil {
		return m.ValBuf
	}
	return nil
}

func (m *Msg) GetValInt() int64 {
	if m != nil {
		return m.ValInt
	}
	return 0
}

func (m *Msg) GetFlags() MsgFlags {
	if m != nil {
		return m.Flags
	}
	return MsgFlags_None
}

func (m *Msg) GetNext() *Msg {
	if m != nil {
		return m.Next
	}
	return nil
}

type PlanetEpoch struct {
	// EpochTID is the genesis Tx ID and is only known after this PlanetEpoch is sealed.
	EpochTID []byte `protobuf:"bytes,1,opt,name=EpochTID,proto3" json:"EpochTID,omitempty"`
	// EpochEntries contains the entries that bootstrap this epoch
	EpochEntries []*Msg `protobuf:"bytes,2,rep,name=EpochEntries,proto3" json:"EpochEntries,omitempty"`
	// CommonName is the commonly used name for this planet
	CommonName string `protobuf:"bytes,3,opt,name=CommonName,proto3" json:"CommonName,omitempty"`
}

func (m *PlanetEpoch) Reset()      { *m = PlanetEpoch{} }
func (*PlanetEpoch) ProtoMessage() {}
func (*PlanetEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{1}
}
func (m *PlanetEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlanetEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlanetEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlanetEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlanetEpoch.Merge(m, src)
}
func (m *PlanetEpoch) XXX_Size() int {
	return m.Size()
}
func (m *PlanetEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_PlanetEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_PlanetEpoch proto.InternalMessageInfo

func (m *PlanetEpoch) GetEpochTID() []byte {
	if m != nil {
		return m.EpochTID
	}
	return nil
}

func (m *PlanetEpoch) GetEpochEntries() []*Msg {
	if m != nil {
		return m.EpochEntries
	}
	return nil
}

func (m *PlanetEpoch) GetCommonName() string {
	if m != nil {
		return m.CommonName
	}
	return ""
}

type UserSeat struct {
	UserID       uint64 `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	HomePlanetID uint64 `protobuf:"varint,4,opt,name=HomePlanetID,proto3" json:"HomePlanetID,omitempty"`
}

func (m *UserSeat) Reset()      { *m = UserSeat{} }
func (*UserSeat) ProtoMessage() {}
func (*UserSeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{2}
}
func (m *UserSeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserSeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserSeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserSeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSeat.Merge(m, src)
}
func (m *UserSeat) XXX_Size() int {
	return m.Size()
}
func (m *UserSeat) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSeat.DiscardUnknown(m)
}

var xxx_messageInfo_UserSeat proto.InternalMessageInfo

func (m *UserSeat) GetUserID() uint64 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserSeat) GetHomePlanetID() uint64 {
	if m != nil {
		return m.HomePlanetID
	}
	return 0
}

type LoginReq struct {
	// A byte string identifying user who is logging in (lot limited to UTF8)
	// This is typically the persistent UID given by the device OS that only changes when the app is reinstalled.
	UserUID []byte `protobuf:"bytes,1,opt,name=UserUID,proto3" json:"UserUID,omitempty"`
}

func (m *LoginReq) Reset()      { *m = LoginReq{} }
func (*LoginReq) ProtoMessage() {}
func (*LoginReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{3}
}
func (m *LoginReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginReq.Merge(m, src)
}
func (m *LoginReq) XXX_Size() int {
	return m.Size()
}
func (m *LoginReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginReq.DiscardUnknown(m)
}

var xxx_messageInfo_LoginReq proto.InternalMessageInfo

func (m *LoginReq) GetUserUID() []byte {
	if m != nil {
		return m.UserUID
	}
	return nil
}

type Symbol struct {
	ID    uint64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (m *Symbol) Reset()      { *m = Symbol{} }
func (*Symbol) ProtoMessage() {}
func (*Symbol) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{4}
}
func (m *Symbol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Symbol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Symbol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Symbol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Symbol.Merge(m, src)
}
func (m *Symbol) XXX_Size() int {
	return m.Size()
}
func (m *Symbol) XXX_DiscardUnknown() {
	xxx_messageInfo_Symbol.DiscardUnknown(m)
}

var xxx_messageInfo_Symbol proto.InternalMessageInfo

func (m *Symbol) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Symbol) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

type Defs struct {
	Symbols []*Symbol     `protobuf:"bytes,1,rep,name=Symbols,proto3" json:"Symbols,omitempty"`
	Schemas []*AttrSchema `protobuf:"bytes,2,rep,name=Schemas,proto3" json:"Schemas,omitempty"`
}

func (m *Defs) Reset()      { *m = Defs{} }
func (*Defs) ProtoMessage() {}
func (*Defs) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{5}
}
func (m *Defs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Defs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Defs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Defs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Defs.Merge(m, src)
}
func (m *Defs) XXX_Size() int {
	return m.Size()
}
func (m *Defs) XXX_DiscardUnknown() {
	xxx_messageInfo_Defs.DiscardUnknown(m)
}

var xxx_messageInfo_Defs proto.InternalMessageInfo

func (m *Defs) GetSymbols() []*Symbol {
	if m != nil {
		return m.Symbols
	}
	return nil
}

func (m *Defs) GetSchemas() []*AttrSchema {
	if m != nil {
		return m.Schemas
	}
	return nil
}

// AttrSchema is a Cell protocol specifier as well as a data packaging schema.
//
// A client forms a CellAttr tree structure, informing how sub cells should be auto-loaded and updated.
//
// Like a protobuf message, once a AttrSchema is published, its fields ("attributes") cannot change type.
// Otherwise, data corruption is possible.
type AttrSchema struct {
	// AppURI specifies which specific app and optional version should handle requests with this schema.
	// The reserved value "." tells the host to choose the default app registered to handle the below CellModelURI (common).
	// e.g.
	//      "."
	//      "planet.tools/amp.app"
	//      "planet.tools/amp.app/v1.2022.1"
	//      "planet.tools/hfs.app/v1.2.3"
	AppURI string `protobuf:"bytes,1,opt,name=AppURI,proto3" json:"AppURI,omitempty"`
	// CellModelURI names a particular data model used by this schema, in effect specifying a namespace / scope for the attached Attrs.
	// This URI names a complete data protocol / specification that this collection of AttrSpecs conforms to (and is a subset of).
	// To an implementing app on the Go side, this URI implies a family of valid possible AttrSpecs to choose from.
	// e.g.
	//      "spotify/v1/artist"
	//      "spotify/v1/album"
	//      "spotify/v1/track"
	//      "filesys/dir"
	//      "filesys/fil"
	CellModelURI string `protobuf:"bytes,3,opt,name=CellModelURI,proto3" json:"CellModelURI,omitempty"`
	// This describes this *particular* AttrSchema, a particular collection of AttrSpecs (and is implicitly scoped within CellModelURI).
	// The host (and its apps) generally don't even look at this field since "{CellModelURI}/{Attrs[i].AttrURI}" fully specifies each attr's data model URI.
	// The can use this for internal identification, usually to link this schema to particular cell view binding.
	SchemaName string `protobuf:"bytes,4,opt,name=SchemaName,proto3" json:"SchemaName,omitempty"`
	// SchemaID is a non-zero, unique, client-generated ID that is bound to this AttrSchema (and registered during RegisterAndResolve).
	// This ID is used in PinReq to specify this particular AttrSchema and persists for the duration of the host session.
	SchemaID int32 `protobuf:"varint,6,opt,name=SchemaID,proto3" json:"SchemaID,omitempty"`
	// Attrs binds a set of AttrSpecs to this SchemaURI.
	Attrs []*AttrSpec `protobuf:"bytes,8,rep,name=Attrs,proto3" json:"Attrs,omitempty"`
}

func (m *AttrSchema) Reset()      { *m = AttrSchema{} }
func (*AttrSchema) ProtoMessage() {}
func (*AttrSchema) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{6}
}
func (m *AttrSchema) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttrSchema) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttrSchema.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttrSchema) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttrSchema.Merge(m, src)
}
func (m *AttrSchema) XXX_Size() int {
	return m.Size()
}
func (m *AttrSchema) XXX_DiscardUnknown() {
	xxx_messageInfo_AttrSchema.DiscardUnknown(m)
}

var xxx_messageInfo_AttrSchema proto.InternalMessageInfo

func (m *AttrSchema) GetAppURI() string {
	if m != nil {
		return m.AppURI
	}
	return ""
}

func (m *AttrSchema) GetCellModelURI() string {
	if m != nil {
		return m.CellModelURI
	}
	return ""
}

func (m *AttrSchema) GetSchemaName() string {
	if m != nil {
		return m.SchemaName
	}
	return ""
}

func (m *AttrSchema) GetSchemaID() int32 {
	if m != nil {
		return m.SchemaID
	}
	return 0
}

func (m *AttrSchema) GetAttrs() []*AttrSpec {
	if m != nil {
		return m.Attrs
	}
	return nil
}

// AttrSpec binds an app data model attr URI to a client-provided AttrID, corresponding to a handler on the client side (typically a UI element).
type AttrSpec struct {
	// AttrURI is a self-describing URI scoped within the parent's CellModelURI.
	// It communicates a purpose or role, for a particular usage context of the attr.
	// It originates from an app data model spec and allows the host to associate an app attr to a client-provided AttrID (and SI when SeriesType == Fixed).
	// e.g. for AttrSchema.CellModelURI == "hfs1/directory"
	//      "v1/creation-time"
	//      "v1/thumbnail.glyph"
	//      "v1/detailed.glyph"
	//      "v1/name"
	//      "v1/status"
	//      "v1/item-count"
	AttrURI string `protobuf:"bytes,2,opt,name=AttrURI,proto3" json:"AttrURI,omitempty"`
	// AttrID is a non-zero, client-generated ID that is bound to the given AttrURI during RegisterAndResolve.
	// This identifies which attr is being updated in a PushAttr Msg and can be thought of as a binding to a given UI entity.
	// Multiple AttrURIs can be bound to the same AttrID and is useful when funneling multiple data model attrs to a single UI element for unified handling.
	AttrID int32 `protobuf:"varint,4,opt,name=AttrID,proto3" json:"AttrID,omitempty"`
	// SeriesType specifies how the client interprets the attr domain SeriesIndex ("SI") integer.
	// Scalar (non-array-like) attrs are typically SeriesType_Fixed since a particular SI value is fixed or "hard-wired" to the given AttrURI.
	SeriesType SeriesType `protobuf:"varint,6,opt,name=SeriesType,proto3,enum=arc.SeriesType" json:"SeriesType,omitempty"`
	// BoundSI specifies which SI value this fixed attr is "hard-wired" to, meaning that a PushAttr Msg has its SI field set to this value.
	// Only used / applicable when SeriesType == SeriesType_Fixed.
	BoundSI int64 `protobuf:"varint,7,opt,name=BoundSI,proto3" json:"BoundSI,omitempty"`
	// ValTypeID is standard ValType enum or a client-generated ID that is bound to the given ValTypeURI.
	// This ID is placed in Msg.ValType in a MsgOp_PushAttr msg.
	ValTypeID ValType `protobuf:"varint,13,opt,name=ValTypeID,proto3,enum=arc.ValType" json:"ValTypeID,omitempty"`
}

func (m *AttrSpec) Reset()      { *m = AttrSpec{} }
func (*AttrSpec) ProtoMessage() {}
func (*AttrSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{7}
}
func (m *AttrSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttrSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttrSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttrSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttrSpec.Merge(m, src)
}
func (m *AttrSpec) XXX_Size() int {
	return m.Size()
}
func (m *AttrSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_AttrSpec.DiscardUnknown(m)
}

var xxx_messageInfo_AttrSpec proto.InternalMessageInfo

func (m *AttrSpec) GetAttrURI() string {
	if m != nil {
		return m.AttrURI
	}
	return ""
}

func (m *AttrSpec) GetAttrID() int32 {
	if m != nil {
		return m.AttrID
	}
	return 0
}

func (m *AttrSpec) GetSeriesType() SeriesType {
	if m != nil {
		return m.SeriesType
	}
	return SeriesType_Fixed
}

func (m *AttrSpec) GetBoundSI() int64 {
	if m != nil {
		return m.BoundSI
	}
	return 0
}

func (m *AttrSpec) GetValTypeID() ValType {
	if m != nil {
		return m.ValTypeID
	}
	return ValType_nil
}

type KwArg struct {
	Key    string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Val    string `protobuf:"bytes,5,opt,name=Val,proto3" json:"Val,omitempty"`
	ValBuf []byte `protobuf:"bytes,6,opt,name=ValBuf,proto3" json:"ValBuf,omitempty"`
}

func (m *KwArg) Reset()      { *m = KwArg{} }
func (*KwArg) ProtoMessage() {}
func (*KwArg) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{8}
}
func (m *KwArg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KwArg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KwArg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KwArg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KwArg.Merge(m, src)
}
func (m *KwArg) XXX_Size() int {
	return m.Size()
}
func (m *KwArg) XXX_DiscardUnknown() {
	xxx_messageInfo_KwArg.DiscardUnknown(m)
}

var xxx_messageInfo_KwArg proto.InternalMessageInfo

func (m *KwArg) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KwArg) GetVal() string {
	if m != nil {
		return m.Val
	}
	return ""
}

func (m *KwArg) GetValBuf() []byte {
	if m != nil {
		return m.ValBuf
	}
	return nil
}

// PinReq is a client request to "pin" a cell, meaning selected attrs and child cells will be pushed to the client.
type PinReq struct {
	// Specifies the request that pushed PinCell to the client, providing context for the cell to be pinned.
	// Set to 0 if PinCell and/or PinURI implies that no parent req exists.
	ParentReqID uint64 `protobuf:"varint,1,opt,name=ParentReqID,proto3" json:"ParentReqID,omitempty"`
	// App-definable params can specify additional context.
	Args []*KwArg `protobuf:"bytes,4,rep,name=Args,proto3" json:"Args,omitempty"`
	// Cell ID to be pinned (or 0 if PinURI does not require a cell ID)
	PinCell uint64 `protobuf:"varint,5,opt,name=PinCell,proto3" json:"PinCell,omitempty"`
	// AttrSchema ID to apply on the cell being pinned, specifying which attrs of the target cell will be pushed to the client.
	ContentSchema int32 `protobuf:"varint,7,opt,name=ContentSchema,proto3" json:"ContentSchema,omitempty"`
	// Specifies which child cell types should be pushed (and which attr schema they should be pushed with).
	// If empty, no child cells are pushed.
	ChildSchemas []int32 `protobuf:"varint,9,rep,packed,name=ChildSchemas,proto3" json:"ChildSchemas,omitempty"`
}

func (m *PinReq) Reset()      { *m = PinReq{} }
func (*PinReq) ProtoMessage() {}
func (*PinReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{9}
}
func (m *PinReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PinReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PinReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PinReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PinReq.Merge(m, src)
}
func (m *PinReq) XXX_Size() int {
	return m.Size()
}
func (m *PinReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PinReq.DiscardUnknown(m)
}

var xxx_messageInfo_PinReq proto.InternalMessageInfo

func (m *PinReq) GetParentReqID() uint64 {
	if m != nil {
		return m.ParentReqID
	}
	return 0
}

func (m *PinReq) GetArgs() []*KwArg {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *PinReq) GetPinCell() uint64 {
	if m != nil {
		return m.PinCell
	}
	return 0
}

func (m *PinReq) GetContentSchema() int32 {
	if m != nil {
		return m.ContentSchema
	}
	return 0
}

func (m *PinReq) GetChildSchemas() []int32 {
	if m != nil {
		return m.ChildSchemas
	}
	return nil
}

type AttrRange struct {
	// Specifies what time series index to start and stop reading at (inclusive).
	SI_SeekTo uint64 `protobuf:"varint,24,opt,name=SI_SeekTo,json=SISeekTo,proto3" json:"SI_SeekTo,omitempty"`
	SI_StopAt uint64 `protobuf:"varint,25,opt,name=SI_StopAt,json=SIStopAt,proto3" json:"SI_StopAt,omitempty"`
	// If set, this limits the number of entries returned for each unique from.cell.attr.  (0 denotes unlimited)
	SI_BatchLimit uint64 `protobuf:"varint,27,opt,name=SI_BatchLimit,json=SIBatchLimit,proto3" json:"SI_BatchLimit,omitempty"`
}

func (m *AttrRange) Reset()      { *m = AttrRange{} }
func (*AttrRange) ProtoMessage() {}
func (*AttrRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{10}
}
func (m *AttrRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttrRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttrRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttrRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttrRange.Merge(m, src)
}
func (m *AttrRange) XXX_Size() int {
	return m.Size()
}
func (m *AttrRange) XXX_DiscardUnknown() {
	xxx_messageInfo_AttrRange.DiscardUnknown(m)
}

var xxx_messageInfo_AttrRange proto.InternalMessageInfo

func (m *AttrRange) GetSI_SeekTo() uint64 {
	if m != nil {
		return m.SI_SeekTo
	}
	return 0
}

func (m *AttrRange) GetSI_StopAt() uint64 {
	if m != nil {
		return m.SI_StopAt
	}
	return 0
}

func (m *AttrRange) GetSI_BatchLimit() uint64 {
	if m != nil {
		return m.SI_BatchLimit
	}
	return 0
}

type GeoFix struct {
	Model  GeoModel `protobuf:"varint,1,opt,name=Model,proto3,enum=arc.GeoModel" json:"Model,omitempty"`
	Lat    float64  `protobuf:"fixed64,4,opt,name=Lat,proto3" json:"Lat,omitempty"`
	Lng    float64  `protobuf:"fixed64,5,opt,name=Lng,proto3" json:"Lng,omitempty"`
	Alt    float64  `protobuf:"fixed64,6,opt,name=Alt,proto3" json:"Alt,omitempty"`
	AltROU float32  `protobuf:"fixed32,10,opt,name=AltROU,proto3" json:"AltROU,omitempty"`
	PosROU float32  `protobuf:"fixed32,11,opt,name=PosROU,proto3" json:"PosROU,omitempty"`
}

func (m *GeoFix) Reset()      { *m = GeoFix{} }
func (*GeoFix) ProtoMessage() {}
func (*GeoFix) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{11}
}
func (m *GeoFix) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeoFix) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeoFix.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeoFix) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeoFix.Merge(m, src)
}
func (m *GeoFix) XXX_Size() int {
	return m.Size()
}
func (m *GeoFix) XXX_DiscardUnknown() {
	xxx_messageInfo_GeoFix.DiscardUnknown(m)
}

var xxx_messageInfo_GeoFix proto.InternalMessageInfo

func (m *GeoFix) GetModel() GeoModel {
	if m != nil {
		return m.Model
	}
	return GeoModel_Sphere
}

func (m *GeoFix) GetLat() float64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

func (m *GeoFix) GetLng() float64 {
	if m != nil {
		return m.Lng
	}
	return 0
}

func (m *GeoFix) GetAlt() float64 {
	if m != nil {
		return m.Alt
	}
	return 0
}

func (m *GeoFix) GetAltROU() float32 {
	if m != nil {
		return m.AltROU
	}
	return 0
}

func (m *GeoFix) GetPosROU() float32 {
	if m != nil {
		return m.PosROU
	}
	return 0
}

// Content is an extensible content wrapper, offering an optional accompanying MIME type.
type Content struct {
	ContentData   []byte  `protobuf:"bytes,3,opt,name=ContentData,proto3" json:"ContentData,omitempty"`
	ContentType   string  `protobuf:"bytes,4,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	ContentTypeID int64   `protobuf:"varint,5,opt,name=ContentTypeID,proto3" json:"ContentTypeID,omitempty"`
	LinksCellID   int64   `protobuf:"varint,10,opt,name=LinksCellID,proto3" json:"LinksCellID,omitempty"`
	Location      *GeoFix `protobuf:"bytes,11,opt,name=Location,proto3" json:"Location,omitempty"`
}

func (m *Content) Reset()      { *m = Content{} }
func (*Content) ProtoMessage() {}
func (*Content) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{12}
}
func (m *Content) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Content) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Content.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Content) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Content.Merge(m, src)
}
func (m *Content) XXX_Size() int {
	return m.Size()
}
func (m *Content) XXX_DiscardUnknown() {
	xxx_messageInfo_Content.DiscardUnknown(m)
}

var xxx_messageInfo_Content proto.InternalMessageInfo

func (m *Content) GetContentData() []byte {
	if m != nil {
		return m.ContentData
	}
	return nil
}

func (m *Content) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *Content) GetContentTypeID() int64 {
	if m != nil {
		return m.ContentTypeID
	}
	return 0
}

func (m *Content) GetLinksCellID() int64 {
	if m != nil {
		return m.LinksCellID
	}
	return 0
}

func (m *Content) GetLocation() *GeoFix {
	if m != nil {
		return m.Location
	}
	return nil
}

type CryptoKey struct {
	CryptoKitID CryptoKitID `protobuf:"varint,1,opt,name=CryptoKitID,proto3,enum=arc.CryptoKitID" json:"CryptoKitID,omitempty"`
	KeyBytes    []byte      `protobuf:"bytes,4,opt,name=KeyBytes,proto3" json:"KeyBytes,omitempty"`
}

func (m *CryptoKey) Reset()      { *m = CryptoKey{} }
func (*CryptoKey) ProtoMessage() {}
func (*CryptoKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{13}
}
func (m *CryptoKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CryptoKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CryptoKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CryptoKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CryptoKey.Merge(m, src)
}
func (m *CryptoKey) XXX_Size() int {
	return m.Size()
}
func (m *CryptoKey) XXX_DiscardUnknown() {
	xxx_messageInfo_CryptoKey.DiscardUnknown(m)
}

var xxx_messageInfo_CryptoKey proto.InternalMessageInfo

func (m *CryptoKey) GetCryptoKitID() CryptoKitID {
	if m != nil {
		return m.CryptoKitID
	}
	return CryptoKit_Nil
}

func (m *CryptoKey) GetKeyBytes() []byte {
	if m != nil {
		return m.KeyBytes
	}
	return nil
}

type Link struct {
	ShapeURI string `protobuf:"bytes,1,opt,name=ShapeURI,proto3" json:"ShapeURI,omitempty"`
	SkinURI  string `protobuf:"bytes,2,opt,name=SkinURI,proto3" json:"SkinURI,omitempty"`
	URL      string `protobuf:"bytes,5,opt,name=URL,proto3" json:"URL,omitempty"`
	Label    string `protobuf:"bytes,7,opt,name=Label,proto3" json:"Label,omitempty"`
	Desc     string `protobuf:"bytes,10,opt,name=Desc,proto3" json:"Desc,omitempty"`
	Tags     string `protobuf:"bytes,12,opt,name=Tags,proto3" json:"Tags,omitempty"`
}

func (m *Link) Reset()      { *m = Link{} }
func (*Link) ProtoMessage() {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{14}
}
func (m *Link) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Link.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return m.Size()
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

func (m *Link) GetShapeURI() string {
	if m != nil {
		return m.ShapeURI
	}
	return ""
}

func (m *Link) GetSkinURI() string {
	if m != nil {
		return m.SkinURI
	}
	return ""
}

func (m *Link) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *Link) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *Link) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *Link) GetTags() string {
	if m != nil {
		return m.Tags
	}
	return ""
}

type TRS struct {
	// X1, X2, and X3 are coordinates or values expressed in any unit.
	// A channel client can later declare how to interpret these coordinates so that a channel server and provide indexed services.
	// Shoutout to the 3 domains that reflect all theoretical completeness: alpha (finite), omega (unending), and the inaccessible cardinal(s).
	// Special thanks to Michael at Vsauce: https://www.youtube.com/watch?v=SrU9YDoXE88
	X1 float64 `protobuf:"fixed64,41,opt,name=X1,proto3" json:"X1,omitempty"`
	X2 float64 `protobuf:"fixed64,42,opt,name=X2,proto3" json:"X2,omitempty"`
	X3 float64 `protobuf:"fixed64,43,opt,name=X3,proto3" json:"X3,omitempty"`
	// Specifies how scale dynamically changes based on observer position.
	ScaleMode TRS_VisualScaleMode `protobuf:"varint,50,opt,name=ScaleMode,proto3,enum=arc.TRS_VisualScaleMode" json:"ScaleMode,omitempty"`
	// Scale1..3 express the scale of this placement.
	// If all three values are 0, they are all implicitly 1.
	// If Scale2 or Scale3 == 0, then it is implicitly Scale1.
	Scale1 float32 `protobuf:"fixed32,51,opt,name=Scale1,proto3" json:"Scale1,omitempty"`
	Scale2 float32 `protobuf:"fixed32,52,opt,name=Scale2,proto3" json:"Scale2,omitempty"`
	Scale3 float32 `protobuf:"fixed32,53,opt,name=Scale3,proto3" json:"Scale3,omitempty"`
	// Rotate1 - Rotate3 the orientation of this placement using Euler angles.
	Rotate1 float32 `protobuf:"fixed32,61,opt,name=Rotate1,proto3" json:"Rotate1,omitempty"`
	Rotate2 float32 `protobuf:"fixed32,62,opt,name=Rotate2,proto3" json:"Rotate2,omitempty"`
	Rotate3 float32 `protobuf:"fixed32,63,opt,name=Rotate3,proto3" json:"Rotate3,omitempty"`
}

func (m *TRS) Reset()      { *m = TRS{} }
func (*TRS) ProtoMessage() {}
func (*TRS) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{15}
}
func (m *TRS) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TRS) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TRS.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TRS) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TRS.Merge(m, src)
}
func (m *TRS) XXX_Size() int {
	return m.Size()
}
func (m *TRS) XXX_DiscardUnknown() {
	xxx_messageInfo_TRS.DiscardUnknown(m)
}

var xxx_messageInfo_TRS proto.InternalMessageInfo

func (m *TRS) GetX1() float64 {
	if m != nil {
		return m.X1
	}
	return 0
}

func (m *TRS) GetX2() float64 {
	if m != nil {
		return m.X2
	}
	return 0
}

func (m *TRS) GetX3() float64 {
	if m != nil {
		return m.X3
	}
	return 0
}

func (m *TRS) GetScaleMode() TRS_VisualScaleMode {
	if m != nil {
		return m.ScaleMode
	}
	return AutoScale
}

func (m *TRS) GetScale1() float32 {
	if m != nil {
		return m.Scale1
	}
	return 0
}

func (m *TRS) GetScale2() float32 {
	if m != nil {
		return m.Scale2
	}
	return 0
}

func (m *TRS) GetScale3() float32 {
	if m != nil {
		return m.Scale3
	}
	return 0
}

func (m *TRS) GetRotate1() float32 {
	if m != nil {
		return m.Rotate1
	}
	return 0
}

func (m *TRS) GetRotate2() float32 {
	if m != nil {
		return m.Rotate2
	}
	return 0
}

func (m *TRS) GetRotate3() float32 {
	if m != nil {
		return m.Rotate3
	}
	return 0
}

type FeedParams struct {
	UpdateIntervalMin float32 `protobuf:"fixed32,2,opt,name=UpdateIntervalMin,proto3" json:"UpdateIntervalMin,omitempty"`
	UpdateIntervalMax float32 `protobuf:"fixed32,3,opt,name=UpdateIntervalMax,proto3" json:"UpdateIntervalMax,omitempty"`
}

func (m *FeedParams) Reset()      { *m = FeedParams{} }
func (*FeedParams) ProtoMessage() {}
func (*FeedParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{16}
}
func (m *FeedParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeedParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeedParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeedParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeedParams.Merge(m, src)
}
func (m *FeedParams) XXX_Size() int {
	return m.Size()
}
func (m *FeedParams) XXX_DiscardUnknown() {
	xxx_messageInfo_FeedParams.DiscardUnknown(m)
}

var xxx_messageInfo_FeedParams proto.InternalMessageInfo

func (m *FeedParams) GetUpdateIntervalMin() float32 {
	if m != nil {
		return m.UpdateIntervalMin
	}
	return 0
}

func (m *FeedParams) GetUpdateIntervalMax() float32 {
	if m != nil {
		return m.UpdateIntervalMax
	}
	return 0
}

type DataSegment struct {
	ByteOfs    uint64 `protobuf:"varint,5,opt,name=ByteOfs,proto3" json:"ByteOfs,omitempty"`
	ByteSz     uint64 `protobuf:"varint,6,opt,name=ByteSz,proto3" json:"ByteSz,omitempty"`
	InlineData []byte `protobuf:"bytes,7,opt,name=InlineData,proto3" json:"InlineData,omitempty"`
	StreamURI  string `protobuf:"bytes,9,opt,name=StreamURI,proto3" json:"StreamURI,omitempty"`
	BlobID     int64  `protobuf:"varint,10,opt,name=BlobID,proto3" json:"BlobID,omitempty"`
}

func (m *DataSegment) Reset()      { *m = DataSegment{} }
func (*DataSegment) ProtoMessage() {}
func (*DataSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{17}
}
func (m *DataSegment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataSegment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSegment.Merge(m, src)
}
func (m *DataSegment) XXX_Size() int {
	return m.Size()
}
func (m *DataSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSegment.DiscardUnknown(m)
}

var xxx_messageInfo_DataSegment proto.InternalMessageInfo

func (m *DataSegment) GetByteOfs() uint64 {
	if m != nil {
		return m.ByteOfs
	}
	return 0
}

func (m *DataSegment) GetByteSz() uint64 {
	if m != nil {
		return m.ByteSz
	}
	return 0
}

func (m *DataSegment) GetInlineData() []byte {
	if m != nil {
		return m.InlineData
	}
	return nil
}

func (m *DataSegment) GetStreamURI() string {
	if m != nil {
		return m.StreamURI
	}
	return ""
}

func (m *DataSegment) GetBlobID() int64 {
	if m != nil {
		return m.BlobID
	}
	return 0
}

// Err wraps errors and is typically used in conjunction with MsgOps.ReqCancel
type Err struct {
	// ErrCode specifying how/why the request was canceled.
	Code ErrCode `protobuf:"varint,1,opt,name=Code,proto3,enum=arc.ErrCode" json:"Code,omitempty"`
	// Msg is a human-readable info string that offers amplifying info about the given error.
	Msg string `protobuf:"bytes,2,opt,name=Msg,proto3" json:"Msg,omitempty"`
}

func (m *Err) Reset()      { *m = Err{} }
func (*Err) ProtoMessage() {}
func (*Err) Descriptor() ([]byte, []int) {
	return fileDescriptor_655fece6a71483b6, []int{18}
}
func (m *Err) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Err) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Err.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Err) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Err.Merge(m, src)
}
func (m *Err) XXX_Size() int {
	return m.Size()
}
func (m *Err) XXX_DiscardUnknown() {
	xxx_messageInfo_Err.DiscardUnknown(m)
}

var xxx_messageInfo_Err proto.InternalMessageInfo

func (m *Err) GetCode() ErrCode {
	if m != nil {
		return m.Code
	}
	return ErrCode_NoErr
}

func (m *Err) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterEnum("arc.Const", Const_name, Const_value)
	proto.RegisterEnum("arc.ValType", ValType_name, ValType_value)
	proto.RegisterEnum("arc.MsgOp", MsgOp_name, MsgOp_value)
	proto.RegisterEnum("arc.MsgFlags", MsgFlags_name, MsgFlags_value)
	proto.RegisterEnum("arc.SeriesType", SeriesType_name, SeriesType_value)
	proto.RegisterEnum("arc.GeoModel", GeoModel_name, GeoModel_value)
	proto.RegisterEnum("arc.CryptoKitID", CryptoKitID_name, CryptoKitID_value)
	proto.RegisterEnum("arc.ErrCode", ErrCode_name, ErrCode_value)
	proto.RegisterEnum("arc.TRS_VisualScaleMode", TRS_VisualScaleMode_name, TRS_VisualScaleMode_value)
	proto.RegisterType((*Msg)(nil), "arc.Msg")
	proto.RegisterType((*PlanetEpoch)(nil), "arc.PlanetEpoch")
	proto.RegisterType((*UserSeat)(nil), "arc.UserSeat")
	proto.RegisterType((*LoginReq)(nil), "arc.LoginReq")
	proto.RegisterType((*Symbol)(nil), "arc.Symbol")
	proto.RegisterType((*Defs)(nil), "arc.Defs")
	proto.RegisterType((*AttrSchema)(nil), "arc.AttrSchema")
	proto.RegisterType((*AttrSpec)(nil), "arc.AttrSpec")
	proto.RegisterType((*KwArg)(nil), "arc.KwArg")
	proto.RegisterType((*PinReq)(nil), "arc.PinReq")
	proto.RegisterType((*AttrRange)(nil), "arc.AttrRange")
	proto.RegisterType((*GeoFix)(nil), "arc.GeoFix")
	proto.RegisterType((*Content)(nil), "arc.Content")
	proto.RegisterType((*CryptoKey)(nil), "arc.CryptoKey")
	proto.RegisterType((*Link)(nil), "arc.Link")
	proto.RegisterType((*TRS)(nil), "arc.TRS")
	proto.RegisterType((*FeedParams)(nil), "arc.FeedParams")
	proto.RegisterType((*DataSegment)(nil), "arc.DataSegment")
	proto.RegisterType((*Err)(nil), "arc.Err")
}

func init() { proto.RegisterFile("arc/arc.proto", fileDescriptor_655fece6a71483b6) }

var fileDescriptor_655fece6a71483b6 = []byte{
	// 2288 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x58, 0xcb, 0x6f, 0x23, 0xc7,
	0xf1, 0xe6, 0x50, 0x24, 0x25, 0xb6, 0x1e, 0xdb, 0xdb, 0xbb, 0xab, 0x9d, 0xd5, 0x0a, 0x34, 0x7f,
	0xb4, 0xfd, 0xa3, 0xac, 0x18, 0x6b, 0x8b, 0xb2, 0x17, 0x71, 0x90, 0x38, 0xa6, 0x48, 0xc9, 0x1e,
	0x58, 0x2f, 0xf4, 0x50, 0xc2, 0x02, 0x39, 0x08, 0x2d, 0xb2, 0x45, 0x4e, 0x76, 0xd8, 0x3d, 0x9e,
	0x69, 0xae, 0x25, 0x9f, 0x7c, 0xcc, 0xc3, 0x79, 0x20, 0x41, 0x72, 0x4a, 0x72, 0x0a, 0x12, 0x7b,
	0x11, 0x04, 0x01, 0x82, 0x20, 0x40, 0xde, 0x47, 0x23, 0x27, 0xe7, 0xe6, 0x63, 0x2c, 0x1f, 0xe2,
	0x43, 0x02, 0xf8, 0x3f, 0x48, 0x50, 0xdd, 0x33, 0xc3, 0x19, 0xd9, 0xb7, 0xae, 0xef, 0xeb, 0x47,
	0x55, 0xf5, 0x57, 0xd5, 0x43, 0xa2, 0x45, 0x16, 0xf6, 0x9f, 0x63, 0x61, 0xff, 0x5e, 0x10, 0x4a,
	0x25, 0xc9, 0x0c, 0x0b, 0xfb, 0x8d, 0xc7, 0x45, 0x34, 0xb3, 0x17, 0x0d, 0xc9, 0x0a, 0x2a, 0x1e,
	0x04, 0xb6, 0x55, 0xb7, 0xd6, 0x96, 0x5a, 0xe8, 0x1e, 0x4c, 0xda, 0x8b, 0x86, 0x07, 0x01, 0x2d,
	0x1e, 0x04, 0xe4, 0x26, 0x2a, 0x53, 0xfe, 0x86, 0xd3, 0xb5, 0x67, 0xea, 0xd6, 0x5a, 0x89, 0x1a,
	0x83, 0x2c, 0xa3, 0x4a, 0x87, 0xfb, 0xbe, 0xd3, 0xb5, 0x2b, 0x1a, 0x8e, 0x2d, 0xc0, 0x77, 0x42,
	0x39, 0x76, 0xba, 0xf6, 0xbc, 0xc1, 0x8d, 0x05, 0x78, 0x5b, 0xa9, 0xd0, 0xe9, 0xda, 0xd7, 0xea,
	0xd6, 0x5a, 0x99, 0xc6, 0x16, 0x59, 0x42, 0x45, 0xd7, 0xb1, 0x71, 0xdd, 0x5a, 0x9b, 0xa1, 0x45,
	0xd7, 0x21, 0xff, 0x8f, 0x66, 0x8f, 0x99, 0xdf, 0xbb, 0x08, 0xb8, 0x7d, 0x53, 0xbb, 0xb3, 0xa0,
	0xdd, 0x89, 0x31, 0x9a, 0x90, 0xb0, 0xdf, 0x31, 0xf3, 0xb7, 0x26, 0x67, 0xf6, 0xad, 0xba, 0xb5,
	0xb6, 0x40, 0x63, 0x2b, 0xc6, 0x1d, 0xa1, 0xec, 0x65, 0xbd, 0x67, 0x6c, 0x91, 0x27, 0x51, 0x79,
	0xc7, 0x67, 0xc3, 0xc8, 0xb6, 0xf5, 0xae, 0x8b, 0x49, 0x90, 0x1a, 0xa4, 0x86, 0x23, 0xab, 0xa8,
	0xb4, 0xcf, 0xcf, 0x95, 0x5d, 0xaf, 0x5b, 0x6b, 0xf3, 0xad, 0xb9, 0x64, 0x0e, 0xd5, 0x68, 0xe3,
	0x4d, 0x34, 0x7f, 0xe8, 0x33, 0xc1, 0xd5, 0x76, 0x20, 0xfb, 0x23, 0xb2, 0x82, 0xe6, 0xf4, 0xa0,
	0xe7, 0x74, 0x75, 0xe6, 0x16, 0x68, 0x6a, 0x93, 0x67, 0xd1, 0x82, 0x1e, 0x6f, 0x0b, 0x15, 0x7a,
	0x3c, 0xb2, 0x8b, 0xf5, 0x99, 0xdc, 0x86, 0x39, 0x96, 0xd4, 0x10, 0xea, 0xc8, 0xf1, 0x58, 0x8a,
	0x7d, 0x36, 0xe6, 0x3a, 0xcd, 0x55, 0x9a, 0x41, 0x1a, 0x3b, 0x68, 0xee, 0x28, 0xe2, 0xa1, 0xcb,
	0x99, 0x82, 0xf8, 0x60, 0xec, 0x74, 0xed, 0xa2, 0xc9, 0xaf, 0xb1, 0x48, 0x03, 0x2d, 0xbc, 0x26,
	0xc7, 0xdc, 0x38, 0xe8, 0x74, 0xed, 0x92, 0x66, 0x73, 0x58, 0xe3, 0x29, 0x34, 0xb7, 0x2b, 0x87,
	0x9e, 0xa0, 0xfc, 0x0d, 0x62, 0xa3, 0x59, 0x58, 0x79, 0x94, 0x3a, 0x9f, 0x98, 0x8d, 0x7b, 0xa8,
	0xe2, 0x5e, 0x8c, 0x4f, 0xa5, 0x0f, 0x77, 0x13, 0xd3, 0x25, 0x5a, 0x74, 0xba, 0xa0, 0x84, 0x63,
	0xe6, 0x4f, 0xb8, 0x3e, 0x7a, 0x81, 0x1a, 0xa3, 0xf1, 0x00, 0x95, 0xba, 0xfc, 0x2c, 0x22, 0x4f,
	0xa3, 0x59, 0xb3, 0x2e, 0xb2, 0x2d, 0x1d, 0xee, 0xbc, 0x0e, 0xd7, 0x60, 0x34, 0xe1, 0xc8, 0x33,
	0x68, 0xd6, 0xed, 0x8f, 0xf8, 0x98, 0x25, 0x59, 0xb9, 0xa6, 0xa7, 0x81, 0x1c, 0x0c, 0x4e, 0x13,
	0xbe, 0xf1, 0x9e, 0x85, 0xd0, 0x14, 0xd7, 0x12, 0x0a, 0x82, 0x23, 0xea, 0x68, 0x97, 0xaa, 0x34,
	0xb6, 0x20, 0x74, 0x10, 0xdf, 0x9e, 0x1c, 0x70, 0x1f, 0x58, 0x93, 0xc0, 0x1c, 0x06, 0x29, 0x36,
	0xbb, 0xe8, 0x14, 0x97, 0x4c, 0x8a, 0xa7, 0x08, 0x5c, 0xa6, 0xb1, 0x62, 0x41, 0x97, 0x69, 0x6a,
	0x83, 0x74, 0xc0, 0x8b, 0xc8, 0x9e, 0xd3, 0xfe, 0x2e, 0x4e, 0xfd, 0x0d, 0x78, 0x9f, 0x1a, 0xae,
	0xf1, 0x5b, 0x0b, 0xcd, 0x25, 0x18, 0x24, 0x17, 0xc6, 0xe0, 0x4c, 0x51, 0x1f, 0x95, 0x98, 0x99,
	0x32, 0x28, 0xe5, 0xca, 0xe0, 0x39, 0x84, 0x5c, 0x0e, 0x62, 0xd0, 0xca, 0xaf, 0x68, 0x8d, 0x9a,
	0xc4, 0x4c, 0x61, 0x9a, 0x99, 0x02, 0x47, 0x6c, 0xc9, 0x89, 0x18, 0xb8, 0x8e, 0x3d, 0xab, 0x85,
	0x9e, 0x98, 0x64, 0x1d, 0x55, 0xe3, 0x22, 0x71, 0xba, 0xf6, 0xe2, 0xe7, 0xd4, 0xd0, 0x94, 0x6e,
	0x74, 0x50, 0xf9, 0xf5, 0x37, 0xdb, 0xe1, 0x90, 0x60, 0x34, 0xf3, 0x3a, 0xbf, 0x88, 0x13, 0x0b,
	0x43, 0x40, 0x8e, 0x99, 0x6f, 0x97, 0x0d, 0x72, 0xcc, 0xfc, 0x4c, 0xc9, 0x55, 0xb2, 0x25, 0xd7,
	0xf8, 0xb5, 0x85, 0x2a, 0x87, 0x46, 0x55, 0x75, 0x34, 0x7f, 0xc8, 0x42, 0x2e, 0x94, 0xe9, 0x18,
	0x46, 0x3a, 0x59, 0x88, 0xd4, 0x50, 0xa9, 0x1d, 0x0e, 0x23, 0xbb, 0xa4, 0x73, 0x69, 0x7a, 0x8d,
	0x76, 0x81, 0x6a, 0x1c, 0xe2, 0x3a, 0xf4, 0x04, 0xdc, 0x9d, 0x3e, 0xba, 0x44, 0x13, 0x93, 0x3c,
	0x85, 0x16, 0x3b, 0x52, 0x28, 0x2e, 0x94, 0xb9, 0x19, 0x1d, 0x77, 0x99, 0xe6, 0x41, 0x2d, 0x86,
	0x91, 0xe7, 0x0f, 0x12, 0x8d, 0x55, 0xeb, 0x33, 0x6b, 0x65, 0x9a, 0xc3, 0x1a, 0x5f, 0x47, 0x55,
	0x48, 0x3b, 0x65, 0x62, 0xc8, 0xc9, 0x5d, 0x54, 0x75, 0x9d, 0x13, 0x97, 0xf3, 0x87, 0x3d, 0xa9,
	0x9b, 0x43, 0x89, 0xce, 0xb9, 0x8e, 0xb1, 0x13, 0x52, 0xc9, 0xa0, 0xad, 0xec, 0x3b, 0x29, 0xa9,
	0x6d, 0xf2, 0x24, 0x5a, 0x74, 0x9d, 0x93, 0x2d, 0xa6, 0xfa, 0xa3, 0x5d, 0x6f, 0xec, 0x29, 0xfb,
	0xae, 0xa9, 0x39, 0xd7, 0x99, 0x62, 0x8d, 0x1f, 0x5a, 0xa8, 0xf2, 0x2a, 0x97, 0x3b, 0xde, 0x39,
	0xe8, 0x48, 0xeb, 0x31, 0xee, 0xb3, 0x46, 0x47, 0xaf, 0x72, 0xa9, 0x41, 0x6a, 0x38, 0x48, 0xfb,
	0x2e, 0x53, 0x5a, 0x1d, 0x16, 0x85, 0xa1, 0x46, 0xc4, 0x50, 0x67, 0x03, 0x10, 0xa1, 0x2f, 0xab,
	0xed, 0x2b, 0x7d, 0x0b, 0x16, 0x85, 0xa1, 0x96, 0x95, 0xaf, 0xe8, 0xc1, 0x91, 0x8d, 0xea, 0xd6,
	0x5a, 0x91, 0xc6, 0x16, 0xe0, 0x87, 0x32, 0x02, 0x7c, 0xde, 0xe0, 0xc6, 0x6a, 0xfc, 0xc5, 0x42,
	0xb3, 0x71, 0xde, 0xe0, 0xce, 0xe2, 0x61, 0x97, 0x29, 0xa6, 0xab, 0x67, 0x81, 0x66, 0xa1, 0xcc,
	0x0c, 0xad, 0x4e, 0x53, 0x3d, 0x59, 0x28, 0x73, 0x37, 0xb1, 0xee, 0xca, 0x5a, 0x93, 0x79, 0x10,
	0xf6, 0xd9, 0xf5, 0xc4, 0xc3, 0x28, 0x7e, 0x38, 0x90, 0x9e, 0x93, 0x85, 0x48, 0x13, 0x3a, 0x54,
	0x9f, 0x29, 0x4f, 0x0a, 0xed, 0x71, 0xd2, 0x44, 0x4c, 0x06, 0x69, 0x4a, 0x36, 0xbe, 0x86, 0xaa,
	0x9d, 0xf0, 0x22, 0x50, 0x12, 0xa4, 0xda, 0x42, 0xf3, 0xb1, 0xe1, 0xa9, 0x58, 0x75, 0x4b, 0x2d,
	0xac, 0x17, 0x66, 0x70, 0x9a, 0x9d, 0x04, 0x05, 0xff, 0x3a, 0xbf, 0xd8, 0xba, 0x50, 0x3c, 0xd2,
	0x01, 0x2d, 0xd0, 0xd4, 0x6e, 0xbc, 0x63, 0xa1, 0x12, 0x78, 0xa5, 0xbb, 0xc2, 0x88, 0x05, 0x7c,
	0xda, 0x73, 0x52, 0x1b, 0x84, 0xea, 0x3e, 0xf4, 0x44, 0xa6, 0xc6, 0x63, 0x13, 0xae, 0xe7, 0x88,
	0xee, 0x26, 0x95, 0x73, 0x44, 0x77, 0xa1, 0x71, 0xee, 0xb2, 0x53, 0xee, 0x6b, 0xc9, 0x56, 0xa9,
	0x31, 0x08, 0x81, 0xc6, 0x19, 0xf5, 0x75, 0x1e, 0xaa, 0x54, 0x8f, 0x01, 0xeb, 0xc1, 0x2b, 0xb5,
	0x60, 0x30, 0x18, 0x37, 0x7e, 0x57, 0x44, 0x33, 0x3d, 0xea, 0x42, 0x3b, 0x7e, 0xb0, 0x61, 0x3f,
	0xa3, 0x6f, 0xbd, 0xf8, 0x60, 0x43, 0xdb, 0x2d, 0x7b, 0x3d, 0xb6, 0x5b, 0xda, 0xde, 0xb4, 0xbf,
	0x10, 0xdb, 0x9b, 0xe4, 0x3e, 0xaa, 0xba, 0x7d, 0xe6, 0x73, 0x10, 0x96, 0xdd, 0xd2, 0x49, 0xb1,
	0x75, 0x52, 0x7a, 0xd4, 0xbd, 0x77, 0xec, 0x45, 0x13, 0xe6, 0xa7, 0x3c, 0x9d, 0x4e, 0x05, 0xd1,
	0x68, 0x63, 0xc3, 0xde, 0x34, 0xa2, 0x31, 0x56, 0x8a, 0xb7, 0xec, 0x17, 0x32, 0x78, 0x2b, 0xc5,
	0x37, 0xed, 0x17, 0x33, 0xf8, 0x26, 0x64, 0x88, 0x4a, 0xc5, 0x14, 0xdf, 0xb0, 0xbf, 0xa2, 0x89,
	0xc4, 0x9c, 0x32, 0x2d, 0xfb, 0xe5, 0x2c, 0xd3, 0x9a, 0x32, 0x9b, 0xf6, 0x57, 0xb3, 0xcc, 0x66,
	0xe3, 0x79, 0x74, 0xed, 0x8a, 0xcf, 0x64, 0x11, 0x55, 0xdb, 0x13, 0x25, 0x35, 0x80, 0x0b, 0x64,
	0x09, 0xa1, 0x1d, 0xef, 0x9c, 0x0f, 0x8c, 0x6d, 0x35, 0x46, 0x08, 0xed, 0x70, 0x3e, 0x38, 0x64,
	0x21, 0x1b, 0x47, 0xe4, 0x59, 0x74, 0xfd, 0x28, 0x18, 0x30, 0xc5, 0x1d, 0xa1, 0x78, 0xf8, 0x88,
	0xf9, 0x7b, 0x9e, 0xd0, 0x37, 0x57, 0xa4, 0x9f, 0x25, 0x3e, 0x67, 0x36, 0x3b, 0xd7, 0xa5, 0xf1,
	0xd9, 0xd9, 0xec, 0xbc, 0xf1, 0x23, 0x0b, 0xcd, 0x43, 0xa5, 0xb8, 0x7c, 0x38, 0x86, 0x92, 0x82,
	0xe6, 0x7c, 0xa1, 0xf8, 0xc1, 0x59, 0x94, 0x34, 0xb1, 0xd8, 0x84, 0x5c, 0xc1, 0xd0, 0x7d, 0x2b,
	0xf9, 0x6c, 0x32, 0x16, 0xbc, 0x4f, 0x8e, 0xf0, 0x3d, 0xc1, 0x75, 0x0d, 0xce, 0x6a, 0x41, 0x66,
	0x10, 0xb2, 0x8a, 0xaa, 0xae, 0x0a, 0x39, 0x1b, 0x83, 0xde, 0xaa, 0x5a, 0x1c, 0x53, 0x40, 0xef,
	0xea, 0xcb, 0xd3, 0xb4, 0xa6, 0x62, 0xab, 0xf1, 0x12, 0x9a, 0xd9, 0x0e, 0x43, 0x52, 0x47, 0xa5,
	0x0e, 0x68, 0xc0, 0xca, 0x3c, 0x06, 0xdb, 0x61, 0x08, 0x18, 0xd5, 0x0c, 0x48, 0x76, 0x2f, 0x1a,
	0xc6, 0x42, 0x86, 0xe1, 0xfa, 0xef, 0x2d, 0x54, 0xee, 0x48, 0x11, 0x29, 0x48, 0xab, 0x1e, 0x9c,
	0xc0, 0x2b, 0x8f, 0x0b, 0xe4, 0x2e, 0xba, 0x6d, 0xec, 0xd7, 0x64, 0xa4, 0x5c, 0x1e, 0x45, 0x9e,
	0x14, 0xa6, 0x7c, 0xf1, 0x0c, 0xb9, 0x89, 0xb0, 0x21, 0xa9, 0x94, 0x2a, 0x46, 0x2b, 0x64, 0x19,
	0x11, 0x83, 0xf6, 0x9c, 0xee, 0x96, 0x27, 0x58, 0x78, 0xb1, 0xcb, 0x05, 0xae, 0xe5, 0x70, 0x57,
	0x85, 0x9e, 0x18, 0x02, 0xfe, 0x3c, 0xb1, 0xd1, 0xcd, 0x14, 0xef, 0x79, 0x63, 0x1e, 0x29, 0x36,
	0x0e, 0xdc, 0xb7, 0xf0, 0x1c, 0xf9, 0x3f, 0xb4, 0x9a, 0x3a, 0xc3, 0x26, 0xbe, 0x7a, 0x35, 0x0c,
	0xfa, 0x2e, 0x0f, 0x1f, 0x79, 0x7d, 0x7e, 0x28, 0x43, 0x85, 0xdf, 0x5f, 0x5b, 0xff, 0x64, 0x26,
	0xfd, 0x84, 0x24, 0xd7, 0xd0, 0x7c, 0x3c, 0x3c, 0x11, 0x9e, 0x8f, 0x0b, 0x59, 0xc0, 0x13, 0x0a,
	0x97, 0xc8, 0x75, 0xb4, 0x98, 0x00, 0xa7, 0x50, 0xfc, 0xb8, 0x42, 0x08, 0x5a, 0x4a, 0xa0, 0x48,
	0x3b, 0x85, 0x67, 0xb3, 0xeb, 0x7a, 0x4e, 0x17, 0x63, 0x08, 0x34, 0x01, 0x92, 0x0f, 0x05, 0x4c,
	0x08, 0x46, 0x0b, 0x09, 0x0a, 0x57, 0x80, 0x97, 0xb3, 0xf3, 0xba, 0x4c, 0x71, 0x88, 0x06, 0xdf,
	0xce, 0xa1, 0x93, 0x50, 0xb7, 0x34, 0x6c, 0x67, 0xd1, 0x76, 0x14, 0x71, 0x75, 0x44, 0x1d, 0x7c,
	0x27, 0x7b, 0xf4, 0x11, 0xdd, 0xc5, 0x2b, 0x59, 0x60, 0x3b, 0x0c, 0x71, 0x8b, 0xdc, 0x46, 0x37,
	0x32, 0x67, 0x24, 0x2a, 0xc4, 0x2f, 0x90, 0x1b, 0xe8, 0x5a, 0x42, 0xc4, 0x9d, 0x18, 0xdf, 0x27,
	0xb7, 0xd0, 0xf5, 0x14, 0x4c, 0x5a, 0x28, 0xfe, 0x62, 0x2e, 0xc2, 0x73, 0x81, 0xbf, 0x94, 0xf5,
	0x26, 0xf9, 0x6a, 0xc4, 0x5f, 0xce, 0x46, 0xa8, 0xf5, 0xf0, 0x72, 0x36, 0x5d, 0xe6, 0x2b, 0x00,
	0xbf, 0x92, 0x3d, 0x23, 0x7d, 0x69, 0xf1, 0x56, 0x76, 0x31, 0xf4, 0x57, 0x7c, 0x98, 0x5d, 0x6c,
	0x7a, 0x3c, 0xa6, 0x39, 0x4f, 0xa8, 0x8b, 0x7b, 0xe4, 0x36, 0x22, 0x69, 0x56, 0x27, 0x9e, 0xaf,
	0x3c, 0xb1, 0xc7, 0xce, 0xf1, 0xbf, 0x66, 0xd7, 0x1f, 0x5b, 0xa8, 0xac, 0x7f, 0xa8, 0x80, 0x48,
	0xf5, 0xe0, 0x64, 0x5f, 0x1e, 0x04, 0xe6, 0x9e, 0x8d, 0xad, 0x5d, 0xc7, 0x16, 0x59, 0x45, 0xb6,
	0x01, 0x28, 0x8f, 0xa4, 0xff, 0x88, 0xb7, 0xc5, 0x80, 0xf2, 0xa1, 0x17, 0x29, 0x1e, 0xe2, 0x32,
	0xa8, 0xc0, 0xb0, 0xf1, 0xc7, 0x86, 0x51, 0x41, 0x0c, 0x4d, 0xa2, 0x11, 0x04, 0x81, 0x11, 0xa4,
	0xc4, 0x60, 0x8e, 0x88, 0x78, 0xa8, 0xf5, 0x8d, 0x97, 0x20, 0x2a, 0x83, 0xc2, 0x27, 0xbb, 0xa7,
	0xb0, 0x4d, 0x6e, 0x24, 0x6b, 0x3b, 0xbe, 0x8c, 0x38, 0xa4, 0xe4, 0xbf, 0xd6, 0xfa, 0x31, 0x9a,
	0x4b, 0x7e, 0x6f, 0xc4, 0xe7, 0xe9, 0xf1, 0xc9, 0xbe, 0x14, 0xdc, 0x94, 0x55, 0x0a, 0xc1, 0xc6,
	0x9d, 0x11, 0xef, 0x3f, 0x0c, 0x24, 0xa8, 0xd4, 0x22, 0x2b, 0xe8, 0x56, 0x4a, 0x9a, 0xaf, 0x2e,
	0x77, 0xc4, 0x42, 0x3e, 0xc0, 0x6f, 0x17, 0xd7, 0xfb, 0xd9, 0x4f, 0x47, 0x70, 0x71, 0x6a, 0x9d,
	0xe8, 0x7e, 0x88, 0x0b, 0x10, 0x4c, 0x06, 0x75, 0xee, 0xbf, 0x80, 0x8b, 0x70, 0x47, 0x19, 0x0c,
	0x84, 0xb9, 0x71, 0x1f, 0x97, 0xaf, 0x6c, 0x70, 0xd4, 0xeb, 0x6c, 0xdc, 0xc7, 0x95, 0xf5, 0x27,
	0xd0, 0x5c, 0xf2, 0xa5, 0x02, 0xaa, 0x4a, 0xc6, 0x27, 0x6e, 0x30, 0xe2, 0x21, 0xc7, 0x85, 0xf5,
	0x1f, 0x5b, 0xb9, 0x47, 0x18, 0x22, 0x4c, 0xcd, 0x93, 0x7d, 0x5d, 0x7b, 0xab, 0xc8, 0x9e, 0x42,
	0x2e, 0xef, 0x87, 0x5c, 0x6d, 0xc9, 0xf3, 0x93, 0x7d, 0xd6, 0xf1, 0xf1, 0x80, 0xac, 0xa0, 0xe5,
	0x29, 0xdb, 0x8e, 0x2e, 0xc6, 0x7b, 0xd1, 0xd0, 0x70, 0x3c, 0xcf, 0xb9, 0xde, 0x50, 0x78, 0x22,
	0xe6, 0xce, 0x48, 0x0d, 0xdd, 0xf9, 0x2c, 0xb7, 0xdd, 0x6d, 0xbd, 0xf8, 0xe2, 0xc6, 0x4b, 0xf8,
	0xef, 0xd6, 0xfa, 0xcf, 0x2b, 0x68, 0x36, 0x6e, 0x76, 0xe0, 0x54, 0x3c, 0x3c, 0xd9, 0x97, 0x50,
	0x3b, 0x05, 0xd0, 0x56, 0x02, 0x1d, 0x09, 0xc1, 0xc6, 0x7c, 0x00, 0xf8, 0x37, 0x9a, 0xc4, 0x46,
	0x37, 0x12, 0x42, 0xb7, 0x7a, 0xc1, 0x7c, 0x60, 0xbe, 0xd9, 0x84, 0xcb, 0x98, 0x2e, 0x89, 0x26,
	0x41, 0x20, 0x43, 0xc5, 0x07, 0x07, 0x01, 0xfe, 0xd6, 0x15, 0xce, 0x1b, 0x07, 0x3e, 0x87, 0x52,
	0xe4, 0x03, 0xfc, 0xed, 0xdc, 0x8e, 0x94, 0xbf, 0xd1, 0x61, 0xa2, 0xcf, 0x7d, 0x3e, 0xc0, 0xef,
	0x34, 0xc9, 0x1d, 0x74, 0x33, 0x61, 0xdc, 0xd1, 0x44, 0x29, 0x4f, 0x0c, 0xbb, 0xf2, 0x4d, 0x81,
	0xbf, 0x93, 0xa3, 0xba, 0x5e, 0xd4, 0x97, 0x42, 0xf0, 0x3e, 0xec, 0xf7, 0xdd, 0x1c, 0xe5, 0x88,
	0x47, 0xcc, 0xf7, 0x06, 0x46, 0xec, 0xdf, 0xbb, 0x7a, 0xd4, 0xbe, 0x54, 0x3b, 0xf0, 0xe3, 0x00,
	0xff, 0xa0, 0x99, 0x8d, 0x37, 0x5e, 0x04, 0xf2, 0xfc, 0xc9, 0xe7, 0x11, 0xd0, 0x7e, 0x7e, 0xda,
	0x24, 0xb7, 0x10, 0x4e, 0x88, 0x2d, 0x36, 0xd0, 0xbf, 0xf9, 0xf0, 0xcf, 0x9a, 0x64, 0x15, 0xdd,
	0x9e, 0xe6, 0x52, 0x8d, 0x3c, 0x31, 0xec, 0xc9, 0xb8, 0x00, 0x7e, 0x91, 0xf3, 0xcd, 0x80, 0x3b,
	0xcc, 0x83, 0x60, 0x7f, 0xd9, 0x24, 0x77, 0xd1, 0x72, 0x42, 0x99, 0x5f, 0xa6, 0xa9, 0x7b, 0xef,
	0xe6, 0xf2, 0x67, 0x48, 0x58, 0x37, 0x09, 0x39, 0x7e, 0x2f, 0x17, 0x54, 0x3b, 0x08, 0xd2, 0x55,
	0x8f, 0x73, 0xa7, 0xed, 0x4b, 0xfd, 0x7b, 0xcc, 0x50, 0xbf, 0xca, 0x2d, 0xda, 0x63, 0xfe, 0x99,
	0x0c, 0xc7, 0x7c, 0xd0, 0x3b, 0xc7, 0xbf, 0xc9, 0x2d, 0x02, 0xa9, 0xa7, 0xfb, 0xfd, 0xa1, 0x09,
	0x9a, 0xba, 0x42, 0x25, 0xbd, 0x82, 0x0f, 0xf0, 0x1f, 0x9b, 0x64, 0x19, 0x5d, 0xcf, 0xa4, 0xc4,
	0xf4, 0x7f, 0xfc, 0xa7, 0xdc, 0x61, 0xd0, 0x88, 0x13, 0xdf, 0xff, 0x7c, 0x45, 0x4d, 0x3a, 0xbb,
	0xba, 0x79, 0xfc, 0x35, 0xc7, 0xec, 0x4b, 0x75, 0xe8, 0x09, 0xc1, 0x4e, 0x7d, 0x8e, 0xff, 0xd6,
	0x24, 0x4f, 0xa0, 0x95, 0x84, 0x39, 0xf6, 0xa4, 0xcf, 0x14, 0x8f, 0xda, 0x41, 0xc0, 0xc5, 0xe0,
	0x40, 0xf8, 0x17, 0xf8, 0xdf, 0x4d, 0xf2, 0x14, 0x7a, 0x62, 0xba, 0x69, 0x34, 0x39, 0x3b, 0xf3,
	0xfa, 0x1e, 0x17, 0xea, 0x90, 0x87, 0x63, 0x4f, 0x3f, 0xcb, 0x11, 0xfe, 0x4f, 0x6e, 0x56, 0x67,
	0x74, 0x18, 0x4a, 0x25, 0xfb, 0xd2, 0xd7, 0x21, 0xf5, 0xe5, 0x50, 0x78, 0x6f, 0xf1, 0x01, 0xfe,
	0xc7, 0x5a, 0x6b, 0x03, 0xcd, 0xc1, 0x7b, 0x0e, 0xef, 0x29, 0x79, 0x1a, 0xcd, 0x67, 0xde, 0x76,
	0x92, 0xfe, 0x6d, 0xb1, 0x92, 0x8e, 0xd6, 0xac, 0xe7, 0xad, 0xad, 0x57, 0x3e, 0xf8, 0xa8, 0x56,
	0xf8, 0xf0, 0xa3, 0x5a, 0xe1, 0xd3, 0x8f, 0x6a, 0xd6, 0xdb, 0x97, 0x35, 0xeb, 0xdd, 0xcb, 0x9a,
	0xf5, 0xfe, 0x65, 0xcd, 0xfa, 0xe0, 0xb2, 0x66, 0xfd, 0xf3, 0xb2, 0x66, 0x7d, 0x72, 0x59, 0x2b,
	0x7c, 0x7a, 0x59, 0xb3, 0xbe, 0xff, 0x71, 0xad, 0xf0, 0xc1, 0xc7, 0xb5, 0xc2, 0x87, 0x1f, 0xd7,
	0x0a, 0x8f, 0x8b, 0xd5, 0x76, 0xd8, 0x7f, 0x40, 0xef, 0xb5, 0xc3, 0xfe, 0x69, 0x45, 0xff, 0x15,
	0xb5, 0xf9, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x82, 0x47, 0xff, 0xb0, 0x9b, 0x12, 0x00, 0x00,
}

func (x Const) String() string {
	s, ok := Const_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ValType) String() string {
	s, ok := ValType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MsgOp) String() string {
	s, ok := MsgOp_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x MsgFlags) String() string {
	s, ok := MsgFlags_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x SeriesType) String() string {
	s, ok := SeriesType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x GeoModel) String() string {
	s, ok := GeoModel_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x CryptoKitID) String() string {
	s, ok := CryptoKitID_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x ErrCode) String() string {
	s, ok := ErrCode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x TRS_VisualScaleMode) String() string {
	s, ok := TRS_VisualScaleMode_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Msg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Msg)
	if !ok {
		that2, ok := that.(Msg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Op != that1.Op {
		return false
	}
	if this.ReqID != that1.ReqID {
		return false
	}
	if this.CellID != that1.CellID {
		return false
	}
	if this.FromID != that1.FromID {
		return false
	}
	if this.AttrID != that1.AttrID {
		return false
	}
	if this.SI != that1.SI {
		return false
	}
	if this.ValType != that1.ValType {
		return false
	}
	if !bytes.Equal(this.ValBuf, that1.ValBuf) {
		return false
	}
	if this.ValInt != that1.ValInt {
		return false
	}
	if this.Flags != that1.Flags {
		return false
	}
	if !this.Next.Equal(that1.Next) {
		return false
	}
	return true
}
func (this *PlanetEpoch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PlanetEpoch)
	if !ok {
		that2, ok := that.(PlanetEpoch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.EpochTID, that1.EpochTID) {
		return false
	}
	if len(this.EpochEntries) != len(that1.EpochEntries) {
		return false
	}
	for i := range this.EpochEntries {
		if !this.EpochEntries[i].Equal(that1.EpochEntries[i]) {
			return false
		}
	}
	if this.CommonName != that1.CommonName {
		return false
	}
	return true
}
func (this *UserSeat) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UserSeat)
	if !ok {
		that2, ok := that.(UserSeat)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserID != that1.UserID {
		return false
	}
	if this.HomePlanetID != that1.HomePlanetID {
		return false
	}
	return true
}
func (this *LoginReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LoginReq)
	if !ok {
		that2, ok := that.(LoginReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.UserUID, that1.UserUID) {
		return false
	}
	return true
}
func (this *Symbol) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Symbol)
	if !ok {
		that2, ok := that.(Symbol)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ID != that1.ID {
		return false
	}
	if !bytes.Equal(this.Value, that1.Value) {
		return false
	}
	return true
}
func (this *Defs) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Defs)
	if !ok {
		that2, ok := that.(Defs)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Symbols) != len(that1.Symbols) {
		return false
	}
	for i := range this.Symbols {
		if !this.Symbols[i].Equal(that1.Symbols[i]) {
			return false
		}
	}
	if len(this.Schemas) != len(that1.Schemas) {
		return false
	}
	for i := range this.Schemas {
		if !this.Schemas[i].Equal(that1.Schemas[i]) {
			return false
		}
	}
	return true
}
func (this *AttrSchema) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttrSchema)
	if !ok {
		that2, ok := that.(AttrSchema)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppURI != that1.AppURI {
		return false
	}
	if this.CellModelURI != that1.CellModelURI {
		return false
	}
	if this.SchemaName != that1.SchemaName {
		return false
	}
	if this.SchemaID != that1.SchemaID {
		return false
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return false
	}
	for i := range this.Attrs {
		if !this.Attrs[i].Equal(that1.Attrs[i]) {
			return false
		}
	}
	return true
}
func (this *AttrSpec) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttrSpec)
	if !ok {
		that2, ok := that.(AttrSpec)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AttrURI != that1.AttrURI {
		return false
	}
	if this.AttrID != that1.AttrID {
		return false
	}
	if this.SeriesType != that1.SeriesType {
		return false
	}
	if this.BoundSI != that1.BoundSI {
		return false
	}
	if this.ValTypeID != that1.ValTypeID {
		return false
	}
	return true
}
func (this *KwArg) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KwArg)
	if !ok {
		that2, ok := that.(KwArg)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Val != that1.Val {
		return false
	}
	if !bytes.Equal(this.ValBuf, that1.ValBuf) {
		return false
	}
	return true
}
func (this *PinReq) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PinReq)
	if !ok {
		that2, ok := that.(PinReq)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ParentReqID != that1.ParentReqID {
		return false
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if !this.Args[i].Equal(that1.Args[i]) {
			return false
		}
	}
	if this.PinCell != that1.PinCell {
		return false
	}
	if this.ContentSchema != that1.ContentSchema {
		return false
	}
	if len(this.ChildSchemas) != len(that1.ChildSchemas) {
		return false
	}
	for i := range this.ChildSchemas {
		if this.ChildSchemas[i] != that1.ChildSchemas[i] {
			return false
		}
	}
	return true
}
func (this *AttrRange) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttrRange)
	if !ok {
		that2, ok := that.(AttrRange)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SI_SeekTo != that1.SI_SeekTo {
		return false
	}
	if this.SI_StopAt != that1.SI_StopAt {
		return false
	}
	if this.SI_BatchLimit != that1.SI_BatchLimit {
		return false
	}
	return true
}
func (this *GeoFix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GeoFix)
	if !ok {
		that2, ok := that.(GeoFix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Model != that1.Model {
		return false
	}
	if this.Lat != that1.Lat {
		return false
	}
	if this.Lng != that1.Lng {
		return false
	}
	if this.Alt != that1.Alt {
		return false
	}
	if this.AltROU != that1.AltROU {
		return false
	}
	if this.PosROU != that1.PosROU {
		return false
	}
	return true
}
func (this *Content) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Content)
	if !ok {
		that2, ok := that.(Content)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.ContentData, that1.ContentData) {
		return false
	}
	if this.ContentType != that1.ContentType {
		return false
	}
	if this.ContentTypeID != that1.ContentTypeID {
		return false
	}
	if this.LinksCellID != that1.LinksCellID {
		return false
	}
	if !this.Location.Equal(that1.Location) {
		return false
	}
	return true
}
func (this *CryptoKey) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CryptoKey)
	if !ok {
		that2, ok := that.(CryptoKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CryptoKitID != that1.CryptoKitID {
		return false
	}
	if !bytes.Equal(this.KeyBytes, that1.KeyBytes) {
		return false
	}
	return true
}
func (this *Link) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Link)
	if !ok {
		that2, ok := that.(Link)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ShapeURI != that1.ShapeURI {
		return false
	}
	if this.SkinURI != that1.SkinURI {
		return false
	}
	if this.URL != that1.URL {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.Desc != that1.Desc {
		return false
	}
	if this.Tags != that1.Tags {
		return false
	}
	return true
}
func (this *TRS) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TRS)
	if !ok {
		that2, ok := that.(TRS)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.X1 != that1.X1 {
		return false
	}
	if this.X2 != that1.X2 {
		return false
	}
	if this.X3 != that1.X3 {
		return false
	}
	if this.ScaleMode != that1.ScaleMode {
		return false
	}
	if this.Scale1 != that1.Scale1 {
		return false
	}
	if this.Scale2 != that1.Scale2 {
		return false
	}
	if this.Scale3 != that1.Scale3 {
		return false
	}
	if this.Rotate1 != that1.Rotate1 {
		return false
	}
	if this.Rotate2 != that1.Rotate2 {
		return false
	}
	if this.Rotate3 != that1.Rotate3 {
		return false
	}
	return true
}
func (this *FeedParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FeedParams)
	if !ok {
		that2, ok := that.(FeedParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UpdateIntervalMin != that1.UpdateIntervalMin {
		return false
	}
	if this.UpdateIntervalMax != that1.UpdateIntervalMax {
		return false
	}
	return true
}
func (this *DataSegment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DataSegment)
	if !ok {
		that2, ok := that.(DataSegment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ByteOfs != that1.ByteOfs {
		return false
	}
	if this.ByteSz != that1.ByteSz {
		return false
	}
	if !bytes.Equal(this.InlineData, that1.InlineData) {
		return false
	}
	if this.StreamURI != that1.StreamURI {
		return false
	}
	if this.BlobID != that1.BlobID {
		return false
	}
	return true
}
func (this *Err) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Err)
	if !ok {
		that2, ok := that.(Err)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Msg != that1.Msg {
		return false
	}
	return true
}
func (this *Msg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&arc.Msg{")
	s = append(s, "Op: "+fmt.Sprintf("%#v", this.Op)+",\n")
	s = append(s, "ReqID: "+fmt.Sprintf("%#v", this.ReqID)+",\n")
	s = append(s, "CellID: "+fmt.Sprintf("%#v", this.CellID)+",\n")
	s = append(s, "FromID: "+fmt.Sprintf("%#v", this.FromID)+",\n")
	s = append(s, "AttrID: "+fmt.Sprintf("%#v", this.AttrID)+",\n")
	s = append(s, "SI: "+fmt.Sprintf("%#v", this.SI)+",\n")
	s = append(s, "ValType: "+fmt.Sprintf("%#v", this.ValType)+",\n")
	s = append(s, "ValBuf: "+fmt.Sprintf("%#v", this.ValBuf)+",\n")
	s = append(s, "ValInt: "+fmt.Sprintf("%#v", this.ValInt)+",\n")
	s = append(s, "Flags: "+fmt.Sprintf("%#v", this.Flags)+",\n")
	if this.Next != nil {
		s = append(s, "Next: "+fmt.Sprintf("%#v", this.Next)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PlanetEpoch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.PlanetEpoch{")
	s = append(s, "EpochTID: "+fmt.Sprintf("%#v", this.EpochTID)+",\n")
	if this.EpochEntries != nil {
		s = append(s, "EpochEntries: "+fmt.Sprintf("%#v", this.EpochEntries)+",\n")
	}
	s = append(s, "CommonName: "+fmt.Sprintf("%#v", this.CommonName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UserSeat) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.UserSeat{")
	s = append(s, "UserID: "+fmt.Sprintf("%#v", this.UserID)+",\n")
	s = append(s, "HomePlanetID: "+fmt.Sprintf("%#v", this.HomePlanetID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LoginReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&arc.LoginReq{")
	s = append(s, "UserUID: "+fmt.Sprintf("%#v", this.UserUID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Symbol) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.Symbol{")
	s = append(s, "ID: "+fmt.Sprintf("%#v", this.ID)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Defs) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.Defs{")
	if this.Symbols != nil {
		s = append(s, "Symbols: "+fmt.Sprintf("%#v", this.Symbols)+",\n")
	}
	if this.Schemas != nil {
		s = append(s, "Schemas: "+fmt.Sprintf("%#v", this.Schemas)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttrSchema) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&arc.AttrSchema{")
	s = append(s, "AppURI: "+fmt.Sprintf("%#v", this.AppURI)+",\n")
	s = append(s, "CellModelURI: "+fmt.Sprintf("%#v", this.CellModelURI)+",\n")
	s = append(s, "SchemaName: "+fmt.Sprintf("%#v", this.SchemaName)+",\n")
	s = append(s, "SchemaID: "+fmt.Sprintf("%#v", this.SchemaID)+",\n")
	if this.Attrs != nil {
		s = append(s, "Attrs: "+fmt.Sprintf("%#v", this.Attrs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttrSpec) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&arc.AttrSpec{")
	s = append(s, "AttrURI: "+fmt.Sprintf("%#v", this.AttrURI)+",\n")
	s = append(s, "AttrID: "+fmt.Sprintf("%#v", this.AttrID)+",\n")
	s = append(s, "SeriesType: "+fmt.Sprintf("%#v", this.SeriesType)+",\n")
	s = append(s, "BoundSI: "+fmt.Sprintf("%#v", this.BoundSI)+",\n")
	s = append(s, "ValTypeID: "+fmt.Sprintf("%#v", this.ValTypeID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KwArg) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.KwArg{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Val: "+fmt.Sprintf("%#v", this.Val)+",\n")
	s = append(s, "ValBuf: "+fmt.Sprintf("%#v", this.ValBuf)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PinReq) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&arc.PinReq{")
	s = append(s, "ParentReqID: "+fmt.Sprintf("%#v", this.ParentReqID)+",\n")
	if this.Args != nil {
		s = append(s, "Args: "+fmt.Sprintf("%#v", this.Args)+",\n")
	}
	s = append(s, "PinCell: "+fmt.Sprintf("%#v", this.PinCell)+",\n")
	s = append(s, "ContentSchema: "+fmt.Sprintf("%#v", this.ContentSchema)+",\n")
	s = append(s, "ChildSchemas: "+fmt.Sprintf("%#v", this.ChildSchemas)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AttrRange) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&arc.AttrRange{")
	s = append(s, "SI_SeekTo: "+fmt.Sprintf("%#v", this.SI_SeekTo)+",\n")
	s = append(s, "SI_StopAt: "+fmt.Sprintf("%#v", this.SI_StopAt)+",\n")
	s = append(s, "SI_BatchLimit: "+fmt.Sprintf("%#v", this.SI_BatchLimit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GeoFix) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&arc.GeoFix{")
	s = append(s, "Model: "+fmt.Sprintf("%#v", this.Model)+",\n")
	s = append(s, "Lat: "+fmt.Sprintf("%#v", this.Lat)+",\n")
	s = append(s, "Lng: "+fmt.Sprintf("%#v", this.Lng)+",\n")
	s = append(s, "Alt: "+fmt.Sprintf("%#v", this.Alt)+",\n")
	s = append(s, "AltROU: "+fmt.Sprintf("%#v", this.AltROU)+",\n")
	s = append(s, "PosROU: "+fmt.Sprintf("%#v", this.PosROU)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Content) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&arc.Content{")
	s = append(s, "ContentData: "+fmt.Sprintf("%#v", this.ContentData)+",\n")
	s = append(s, "ContentType: "+fmt.Sprintf("%#v", this.ContentType)+",\n")
	s = append(s, "ContentTypeID: "+fmt.Sprintf("%#v", this.ContentTypeID)+",\n")
	s = append(s, "LinksCellID: "+fmt.Sprintf("%#v", this.LinksCellID)+",\n")
	if this.Location != nil {
		s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CryptoKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.CryptoKey{")
	s = append(s, "CryptoKitID: "+fmt.Sprintf("%#v", this.CryptoKitID)+",\n")
	s = append(s, "KeyBytes: "+fmt.Sprintf("%#v", this.KeyBytes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Link) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&arc.Link{")
	s = append(s, "ShapeURI: "+fmt.Sprintf("%#v", this.ShapeURI)+",\n")
	s = append(s, "SkinURI: "+fmt.Sprintf("%#v", this.SkinURI)+",\n")
	s = append(s, "URL: "+fmt.Sprintf("%#v", this.URL)+",\n")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	s = append(s, "Desc: "+fmt.Sprintf("%#v", this.Desc)+",\n")
	s = append(s, "Tags: "+fmt.Sprintf("%#v", this.Tags)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TRS) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&arc.TRS{")
	s = append(s, "X1: "+fmt.Sprintf("%#v", this.X1)+",\n")
	s = append(s, "X2: "+fmt.Sprintf("%#v", this.X2)+",\n")
	s = append(s, "X3: "+fmt.Sprintf("%#v", this.X3)+",\n")
	s = append(s, "ScaleMode: "+fmt.Sprintf("%#v", this.ScaleMode)+",\n")
	s = append(s, "Scale1: "+fmt.Sprintf("%#v", this.Scale1)+",\n")
	s = append(s, "Scale2: "+fmt.Sprintf("%#v", this.Scale2)+",\n")
	s = append(s, "Scale3: "+fmt.Sprintf("%#v", this.Scale3)+",\n")
	s = append(s, "Rotate1: "+fmt.Sprintf("%#v", this.Rotate1)+",\n")
	s = append(s, "Rotate2: "+fmt.Sprintf("%#v", this.Rotate2)+",\n")
	s = append(s, "Rotate3: "+fmt.Sprintf("%#v", this.Rotate3)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FeedParams) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.FeedParams{")
	s = append(s, "UpdateIntervalMin: "+fmt.Sprintf("%#v", this.UpdateIntervalMin)+",\n")
	s = append(s, "UpdateIntervalMax: "+fmt.Sprintf("%#v", this.UpdateIntervalMax)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DataSegment) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&arc.DataSegment{")
	s = append(s, "ByteOfs: "+fmt.Sprintf("%#v", this.ByteOfs)+",\n")
	s = append(s, "ByteSz: "+fmt.Sprintf("%#v", this.ByteSz)+",\n")
	s = append(s, "InlineData: "+fmt.Sprintf("%#v", this.InlineData)+",\n")
	s = append(s, "StreamURI: "+fmt.Sprintf("%#v", this.StreamURI)+",\n")
	s = append(s, "BlobID: "+fmt.Sprintf("%#v", this.BlobID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Err) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&arc.Err{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringArc(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// HostGrpcClient is the client API for HostGrpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type HostGrpcClient interface {
	// HostSession is full duplex connected between two Planet hosts.
	// The return stream reports completion or status of active requests and will remain open as long as the client stream remains open.
	HostSession(ctx context.Context, opts ...grpc.CallOption) (HostGrpc_HostSessionClient, error)
}

type hostGrpcClient struct {
	cc *grpc.ClientConn
}

func NewHostGrpcClient(cc *grpc.ClientConn) HostGrpcClient {
	return &hostGrpcClient{cc}
}

func (c *hostGrpcClient) HostSession(ctx context.Context, opts ...grpc.CallOption) (HostGrpc_HostSessionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_HostGrpc_serviceDesc.Streams[0], "/arc.HostGrpc/HostSession", opts...)
	if err != nil {
		return nil, err
	}
	x := &hostGrpcHostSessionClient{stream}
	return x, nil
}

type HostGrpc_HostSessionClient interface {
	Send(*Msg) error
	Recv() (*Msg, error)
	grpc.ClientStream
}

type hostGrpcHostSessionClient struct {
	grpc.ClientStream
}

func (x *hostGrpcHostSessionClient) Send(m *Msg) error {
	return x.ClientStream.SendMsg(m)
}

func (x *hostGrpcHostSessionClient) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// HostGrpcServer is the server API for HostGrpc service.
type HostGrpcServer interface {
	// HostSession is full duplex connected between two Planet hosts.
	// The return stream reports completion or status of active requests and will remain open as long as the client stream remains open.
	HostSession(HostGrpc_HostSessionServer) error
}

// UnimplementedHostGrpcServer can be embedded to have forward compatible implementations.
type UnimplementedHostGrpcServer struct {
}

func (*UnimplementedHostGrpcServer) HostSession(srv HostGrpc_HostSessionServer) error {
	return status.Errorf(codes.Unimplemented, "method HostSession not implemented")
}

func RegisterHostGrpcServer(s *grpc.Server, srv HostGrpcServer) {
	s.RegisterService(&_HostGrpc_serviceDesc, srv)
}

func _HostGrpc_HostSession_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HostGrpcServer).HostSession(&hostGrpcHostSessionServer{stream})
}

type HostGrpc_HostSessionServer interface {
	Send(*Msg) error
	Recv() (*Msg, error)
	grpc.ServerStream
}

type hostGrpcHostSessionServer struct {
	grpc.ServerStream
}

func (x *hostGrpcHostSessionServer) Send(m *Msg) error {
	return x.ServerStream.SendMsg(m)
}

func (x *hostGrpcHostSessionServer) Recv() (*Msg, error) {
	m := new(Msg)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _HostGrpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arc.HostGrpc",
	HandlerType: (*HostGrpcServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "HostSession",
			Handler:       _HostGrpc_HostSession_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "arc/arc.proto",
}

func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Next != nil {
		{
			size, err := m.Next.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.Flags != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Flags))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.ValInt != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ValInt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if len(m.ValBuf) > 0 {
		i -= len(m.ValBuf)
		copy(dAtA[i:], m.ValBuf)
		i = encodeVarintArc(dAtA, i, uint64(len(m.ValBuf)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ValType != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ValType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SI != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SI))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.AttrID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.AttrID))
		i--
		dAtA[i] = 0x78
	}
	if m.FromID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.FromID))
		i--
		dAtA[i] = 0x58
	}
	if m.CellID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.CellID))
		i--
		dAtA[i] = 0x30
	}
	if m.ReqID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ReqID))
		i--
		dAtA[i] = 0x18
	}
	if m.Op != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlanetEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlanetEpoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlanetEpoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CommonName) > 0 {
		i -= len(m.CommonName)
		copy(dAtA[i:], m.CommonName)
		i = encodeVarintArc(dAtA, i, uint64(len(m.CommonName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EpochEntries) > 0 {
		for iNdEx := len(m.EpochEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EpochEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.EpochTID) > 0 {
		i -= len(m.EpochTID)
		copy(dAtA[i:], m.EpochTID)
		i = encodeVarintArc(dAtA, i, uint64(len(m.EpochTID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserSeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserSeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HomePlanetID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.HomePlanetID))
		i--
		dAtA[i] = 0x20
	}
	if m.UserID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x10
	}
	return len(dAtA) - i, nil
}

func (m *LoginReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserUID) > 0 {
		i -= len(m.UserUID)
		copy(dAtA[i:], m.UserUID)
		i = encodeVarintArc(dAtA, i, uint64(len(m.UserUID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Symbol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Symbol) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Symbol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Defs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Defs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Defs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Schemas) > 0 {
		for iNdEx := len(m.Schemas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schemas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Symbols) > 0 {
		for iNdEx := len(m.Symbols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Symbols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AttrSchema) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttrSchema) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttrSchema) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attrs) > 0 {
		for iNdEx := len(m.Attrs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attrs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.SchemaID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SchemaID))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SchemaName) > 0 {
		i -= len(m.SchemaName)
		copy(dAtA[i:], m.SchemaName)
		i = encodeVarintArc(dAtA, i, uint64(len(m.SchemaName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CellModelURI) > 0 {
		i -= len(m.CellModelURI)
		copy(dAtA[i:], m.CellModelURI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.CellModelURI)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppURI) > 0 {
		i -= len(m.AppURI)
		copy(dAtA[i:], m.AppURI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.AppURI)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttrSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttrSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttrSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValTypeID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ValTypeID))
		i--
		dAtA[i] = 0x68
	}
	if m.BoundSI != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.BoundSI))
		i--
		dAtA[i] = 0x38
	}
	if m.SeriesType != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SeriesType))
		i--
		dAtA[i] = 0x30
	}
	if m.AttrID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.AttrID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AttrURI) > 0 {
		i -= len(m.AttrURI)
		copy(dAtA[i:], m.AttrURI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.AttrURI)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *KwArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KwArg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KwArg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValBuf) > 0 {
		i -= len(m.ValBuf)
		copy(dAtA[i:], m.ValBuf)
		i = encodeVarintArc(dAtA, i, uint64(len(m.ValBuf)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Val) > 0 {
		i -= len(m.Val)
		copy(dAtA[i:], m.Val)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Val)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PinReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PinReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PinReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChildSchemas) > 0 {
		dAtA3 := make([]byte, len(m.ChildSchemas)*10)
		var j2 int
		for _, num1 := range m.ChildSchemas {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintArc(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x4a
	}
	if m.ContentSchema != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ContentSchema))
		i--
		dAtA[i] = 0x38
	}
	if m.PinCell != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.PinCell))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Args[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintArc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.ParentReqID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ParentReqID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AttrRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttrRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttrRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SI_BatchLimit != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SI_BatchLimit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.SI_StopAt != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SI_StopAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.SI_SeekTo != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.SI_SeekTo))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	return len(dAtA) - i, nil
}

func (m *GeoFix) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeoFix) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeoFix) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PosROU != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PosROU))))
		i--
		dAtA[i] = 0x5d
	}
	if m.AltROU != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AltROU))))
		i--
		dAtA[i] = 0x55
	}
	if m.Alt != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Alt))))
		i--
		dAtA[i] = 0x31
	}
	if m.Lng != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lng))))
		i--
		dAtA[i] = 0x29
	}
	if m.Lat != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lat))))
		i--
		dAtA[i] = 0x21
	}
	if m.Model != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Model))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Content) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Content) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Content) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintArc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.LinksCellID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.LinksCellID))
		i--
		dAtA[i] = 0x50
	}
	if m.ContentTypeID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ContentTypeID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintArc(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContentData) > 0 {
		i -= len(m.ContentData)
		copy(dAtA[i:], m.ContentData)
		i = encodeVarintArc(dAtA, i, uint64(len(m.ContentData)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *CryptoKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CryptoKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CryptoKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyBytes) > 0 {
		i -= len(m.KeyBytes)
		copy(dAtA[i:], m.KeyBytes)
		i = encodeVarintArc(dAtA, i, uint64(len(m.KeyBytes)))
		i--
		dAtA[i] = 0x22
	}
	if m.CryptoKitID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.CryptoKitID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Link) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		i -= len(m.Tags)
		copy(dAtA[i:], m.Tags)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Tags)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Desc) > 0 {
		i -= len(m.Desc)
		copy(dAtA[i:], m.Desc)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Desc)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintArc(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SkinURI) > 0 {
		i -= len(m.SkinURI)
		copy(dAtA[i:], m.SkinURI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.SkinURI)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ShapeURI) > 0 {
		i -= len(m.ShapeURI)
		copy(dAtA[i:], m.ShapeURI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.ShapeURI)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TRS) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TRS) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TRS) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rotate3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate3))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xfd
	}
	if m.Rotate2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate2))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xf5
	}
	if m.Rotate1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rotate1))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xed
	}
	if m.Scale3 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale3))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xad
	}
	if m.Scale2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale2))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa5
	}
	if m.Scale1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Scale1))))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9d
	}
	if m.ScaleMode != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ScaleMode))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if m.X3 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X3))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd9
	}
	if m.X2 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X2))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd1
	}
	if m.X1 != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.X1))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc9
	}
	return len(dAtA) - i, nil
}

func (m *FeedParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeedParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeedParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateIntervalMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UpdateIntervalMax))))
		i--
		dAtA[i] = 0x1d
	}
	if m.UpdateIntervalMin != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.UpdateIntervalMin))))
		i--
		dAtA[i] = 0x15
	}
	return len(dAtA) - i, nil
}

func (m *DataSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlobID != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.BlobID))
		i--
		dAtA[i] = 0x50
	}
	if len(m.StreamURI) > 0 {
		i -= len(m.StreamURI)
		copy(dAtA[i:], m.StreamURI)
		i = encodeVarintArc(dAtA, i, uint64(len(m.StreamURI)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.InlineData) > 0 {
		i -= len(m.InlineData)
		copy(dAtA[i:], m.InlineData)
		i = encodeVarintArc(dAtA, i, uint64(len(m.InlineData)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ByteSz != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ByteSz))
		i--
		dAtA[i] = 0x30
	}
	if m.ByteOfs != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.ByteOfs))
		i--
		dAtA[i] = 0x28
	}
	return len(dAtA) - i, nil
}

func (m *Err) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Err) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Err) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintArc(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintArc(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintArc(dAtA []byte, offset int, v uint64) int {
	offset -= sovArc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovArc(uint64(m.Op))
	}
	if m.ReqID != 0 {
		n += 1 + sovArc(uint64(m.ReqID))
	}
	if m.CellID != 0 {
		n += 1 + sovArc(uint64(m.CellID))
	}
	if m.FromID != 0 {
		n += 1 + sovArc(uint64(m.FromID))
	}
	if m.AttrID != 0 {
		n += 1 + sovArc(uint64(m.AttrID))
	}
	if m.SI != 0 {
		n += 2 + sovArc(uint64(m.SI))
	}
	if m.ValType != 0 {
		n += 2 + sovArc(uint64(m.ValType))
	}
	l = len(m.ValBuf)
	if l > 0 {
		n += 2 + l + sovArc(uint64(l))
	}
	if m.ValInt != 0 {
		n += 2 + sovArc(uint64(m.ValInt))
	}
	if m.Flags != 0 {
		n += 2 + sovArc(uint64(m.Flags))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 2 + l + sovArc(uint64(l))
	}
	return n
}

func (m *PlanetEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EpochTID)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if len(m.EpochEntries) > 0 {
		for _, e := range m.EpochEntries {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	l = len(m.CommonName)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *UserSeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovArc(uint64(m.UserID))
	}
	if m.HomePlanetID != 0 {
		n += 1 + sovArc(uint64(m.HomePlanetID))
	}
	return n
}

func (m *LoginReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserUID)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *Symbol) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovArc(uint64(m.ID))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *Defs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Symbols) > 0 {
		for _, e := range m.Symbols {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	if len(m.Schemas) > 0 {
		for _, e := range m.Schemas {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	return n
}

func (m *AttrSchema) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppURI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.CellModelURI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.SchemaName)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.SchemaID != 0 {
		n += 1 + sovArc(uint64(m.SchemaID))
	}
	if len(m.Attrs) > 0 {
		for _, e := range m.Attrs {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	return n
}

func (m *AttrSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AttrURI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.AttrID != 0 {
		n += 1 + sovArc(uint64(m.AttrID))
	}
	if m.SeriesType != 0 {
		n += 1 + sovArc(uint64(m.SeriesType))
	}
	if m.BoundSI != 0 {
		n += 1 + sovArc(uint64(m.BoundSI))
	}
	if m.ValTypeID != 0 {
		n += 1 + sovArc(uint64(m.ValTypeID))
	}
	return n
}

func (m *KwArg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.Val)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.ValBuf)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *PinReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParentReqID != 0 {
		n += 1 + sovArc(uint64(m.ParentReqID))
	}
	if len(m.Args) > 0 {
		for _, e := range m.Args {
			l = e.Size()
			n += 1 + l + sovArc(uint64(l))
		}
	}
	if m.PinCell != 0 {
		n += 1 + sovArc(uint64(m.PinCell))
	}
	if m.ContentSchema != 0 {
		n += 1 + sovArc(uint64(m.ContentSchema))
	}
	if len(m.ChildSchemas) > 0 {
		l = 0
		for _, e := range m.ChildSchemas {
			l += sovArc(uint64(e))
		}
		n += 1 + sovArc(uint64(l)) + l
	}
	return n
}

func (m *AttrRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SI_SeekTo != 0 {
		n += 2 + sovArc(uint64(m.SI_SeekTo))
	}
	if m.SI_StopAt != 0 {
		n += 2 + sovArc(uint64(m.SI_StopAt))
	}
	if m.SI_BatchLimit != 0 {
		n += 2 + sovArc(uint64(m.SI_BatchLimit))
	}
	return n
}

func (m *GeoFix) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Model != 0 {
		n += 1 + sovArc(uint64(m.Model))
	}
	if m.Lat != 0 {
		n += 9
	}
	if m.Lng != 0 {
		n += 9
	}
	if m.Alt != 0 {
		n += 9
	}
	if m.AltROU != 0 {
		n += 5
	}
	if m.PosROU != 0 {
		n += 5
	}
	return n
}

func (m *Content) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContentData)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.ContentTypeID != 0 {
		n += 1 + sovArc(uint64(m.ContentTypeID))
	}
	if m.LinksCellID != 0 {
		n += 1 + sovArc(uint64(m.LinksCellID))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *CryptoKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CryptoKitID != 0 {
		n += 1 + sovArc(uint64(m.CryptoKitID))
	}
	l = len(m.KeyBytes)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ShapeURI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.SkinURI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.Tags)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func (m *TRS) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.X1 != 0 {
		n += 10
	}
	if m.X2 != 0 {
		n += 10
	}
	if m.X3 != 0 {
		n += 10
	}
	if m.ScaleMode != 0 {
		n += 2 + sovArc(uint64(m.ScaleMode))
	}
	if m.Scale1 != 0 {
		n += 6
	}
	if m.Scale2 != 0 {
		n += 6
	}
	if m.Scale3 != 0 {
		n += 6
	}
	if m.Rotate1 != 0 {
		n += 6
	}
	if m.Rotate2 != 0 {
		n += 6
	}
	if m.Rotate3 != 0 {
		n += 6
	}
	return n
}

func (m *FeedParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateIntervalMin != 0 {
		n += 5
	}
	if m.UpdateIntervalMax != 0 {
		n += 5
	}
	return n
}

func (m *DataSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ByteOfs != 0 {
		n += 1 + sovArc(uint64(m.ByteOfs))
	}
	if m.ByteSz != 0 {
		n += 1 + sovArc(uint64(m.ByteSz))
	}
	l = len(m.InlineData)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	l = len(m.StreamURI)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	if m.BlobID != 0 {
		n += 1 + sovArc(uint64(m.BlobID))
	}
	return n
}

func (m *Err) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovArc(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovArc(uint64(l))
	}
	return n
}

func sovArc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozArc(x uint64) (n int) {
	return sovArc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Msg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Msg{`,
		`Op:` + fmt.Sprintf("%v", this.Op) + `,`,
		`ReqID:` + fmt.Sprintf("%v", this.ReqID) + `,`,
		`CellID:` + fmt.Sprintf("%v", this.CellID) + `,`,
		`FromID:` + fmt.Sprintf("%v", this.FromID) + `,`,
		`AttrID:` + fmt.Sprintf("%v", this.AttrID) + `,`,
		`SI:` + fmt.Sprintf("%v", this.SI) + `,`,
		`ValType:` + fmt.Sprintf("%v", this.ValType) + `,`,
		`ValBuf:` + fmt.Sprintf("%v", this.ValBuf) + `,`,
		`ValInt:` + fmt.Sprintf("%v", this.ValInt) + `,`,
		`Flags:` + fmt.Sprintf("%v", this.Flags) + `,`,
		`Next:` + strings.Replace(this.Next.String(), "Msg", "Msg", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PlanetEpoch) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForEpochEntries := "[]*Msg{"
	for _, f := range this.EpochEntries {
		repeatedStringForEpochEntries += strings.Replace(f.String(), "Msg", "Msg", 1) + ","
	}
	repeatedStringForEpochEntries += "}"
	s := strings.Join([]string{`&PlanetEpoch{`,
		`EpochTID:` + fmt.Sprintf("%v", this.EpochTID) + `,`,
		`EpochEntries:` + repeatedStringForEpochEntries + `,`,
		`CommonName:` + fmt.Sprintf("%v", this.CommonName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UserSeat) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UserSeat{`,
		`UserID:` + fmt.Sprintf("%v", this.UserID) + `,`,
		`HomePlanetID:` + fmt.Sprintf("%v", this.HomePlanetID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LoginReq) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LoginReq{`,
		`UserUID:` + fmt.Sprintf("%v", this.UserUID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Symbol) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Symbol{`,
		`ID:` + fmt.Sprintf("%v", this.ID) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Defs) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForSymbols := "[]*Symbol{"
	for _, f := range this.Symbols {
		repeatedStringForSymbols += strings.Replace(f.String(), "Symbol", "Symbol", 1) + ","
	}
	repeatedStringForSymbols += "}"
	repeatedStringForSchemas := "[]*AttrSchema{"
	for _, f := range this.Schemas {
		repeatedStringForSchemas += strings.Replace(f.String(), "AttrSchema", "AttrSchema", 1) + ","
	}
	repeatedStringForSchemas += "}"
	s := strings.Join([]string{`&Defs{`,
		`Symbols:` + repeatedStringForSymbols + `,`,
		`Schemas:` + repeatedStringForSchemas + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttrSchema) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAttrs := "[]*AttrSpec{"
	for _, f := range this.Attrs {
		repeatedStringForAttrs += strings.Replace(f.String(), "AttrSpec", "AttrSpec", 1) + ","
	}
	repeatedStringForAttrs += "}"
	s := strings.Join([]string{`&AttrSchema{`,
		`AppURI:` + fmt.Sprintf("%v", this.AppURI) + `,`,
		`CellModelURI:` + fmt.Sprintf("%v", this.CellModelURI) + `,`,
		`SchemaName:` + fmt.Sprintf("%v", this.SchemaName) + `,`,
		`SchemaID:` + fmt.Sprintf("%v", this.SchemaID) + `,`,
		`Attrs:` + repeatedStringForAttrs + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttrSpec) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttrSpec{`,
		`AttrURI:` + fmt.Sprintf("%v", this.AttrURI) + `,`,
		`AttrID:` + fmt.Sprintf("%v", this.AttrID) + `,`,
		`SeriesType:` + fmt.Sprintf("%v", this.SeriesType) + `,`,
		`BoundSI:` + fmt.Sprintf("%v", this.BoundSI) + `,`,
		`ValTypeID:` + fmt.Sprintf("%v", this.ValTypeID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *KwArg) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&KwArg{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Val:` + fmt.Sprintf("%v", this.Val) + `,`,
		`ValBuf:` + fmt.Sprintf("%v", this.ValBuf) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PinReq) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForArgs := "[]*KwArg{"
	for _, f := range this.Args {
		repeatedStringForArgs += strings.Replace(f.String(), "KwArg", "KwArg", 1) + ","
	}
	repeatedStringForArgs += "}"
	s := strings.Join([]string{`&PinReq{`,
		`ParentReqID:` + fmt.Sprintf("%v", this.ParentReqID) + `,`,
		`Args:` + repeatedStringForArgs + `,`,
		`PinCell:` + fmt.Sprintf("%v", this.PinCell) + `,`,
		`ContentSchema:` + fmt.Sprintf("%v", this.ContentSchema) + `,`,
		`ChildSchemas:` + fmt.Sprintf("%v", this.ChildSchemas) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AttrRange) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AttrRange{`,
		`SI_SeekTo:` + fmt.Sprintf("%v", this.SI_SeekTo) + `,`,
		`SI_StopAt:` + fmt.Sprintf("%v", this.SI_StopAt) + `,`,
		`SI_BatchLimit:` + fmt.Sprintf("%v", this.SI_BatchLimit) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GeoFix) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GeoFix{`,
		`Model:` + fmt.Sprintf("%v", this.Model) + `,`,
		`Lat:` + fmt.Sprintf("%v", this.Lat) + `,`,
		`Lng:` + fmt.Sprintf("%v", this.Lng) + `,`,
		`Alt:` + fmt.Sprintf("%v", this.Alt) + `,`,
		`AltROU:` + fmt.Sprintf("%v", this.AltROU) + `,`,
		`PosROU:` + fmt.Sprintf("%v", this.PosROU) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Content) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Content{`,
		`ContentData:` + fmt.Sprintf("%v", this.ContentData) + `,`,
		`ContentType:` + fmt.Sprintf("%v", this.ContentType) + `,`,
		`ContentTypeID:` + fmt.Sprintf("%v", this.ContentTypeID) + `,`,
		`LinksCellID:` + fmt.Sprintf("%v", this.LinksCellID) + `,`,
		`Location:` + strings.Replace(this.Location.String(), "GeoFix", "GeoFix", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CryptoKey) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CryptoKey{`,
		`CryptoKitID:` + fmt.Sprintf("%v", this.CryptoKitID) + `,`,
		`KeyBytes:` + fmt.Sprintf("%v", this.KeyBytes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Link) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Link{`,
		`ShapeURI:` + fmt.Sprintf("%v", this.ShapeURI) + `,`,
		`SkinURI:` + fmt.Sprintf("%v", this.SkinURI) + `,`,
		`URL:` + fmt.Sprintf("%v", this.URL) + `,`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`Desc:` + fmt.Sprintf("%v", this.Desc) + `,`,
		`Tags:` + fmt.Sprintf("%v", this.Tags) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TRS) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TRS{`,
		`X1:` + fmt.Sprintf("%v", this.X1) + `,`,
		`X2:` + fmt.Sprintf("%v", this.X2) + `,`,
		`X3:` + fmt.Sprintf("%v", this.X3) + `,`,
		`ScaleMode:` + fmt.Sprintf("%v", this.ScaleMode) + `,`,
		`Scale1:` + fmt.Sprintf("%v", this.Scale1) + `,`,
		`Scale2:` + fmt.Sprintf("%v", this.Scale2) + `,`,
		`Scale3:` + fmt.Sprintf("%v", this.Scale3) + `,`,
		`Rotate1:` + fmt.Sprintf("%v", this.Rotate1) + `,`,
		`Rotate2:` + fmt.Sprintf("%v", this.Rotate2) + `,`,
		`Rotate3:` + fmt.Sprintf("%v", this.Rotate3) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FeedParams) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FeedParams{`,
		`UpdateIntervalMin:` + fmt.Sprintf("%v", this.UpdateIntervalMin) + `,`,
		`UpdateIntervalMax:` + fmt.Sprintf("%v", this.UpdateIntervalMax) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DataSegment) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DataSegment{`,
		`ByteOfs:` + fmt.Sprintf("%v", this.ByteOfs) + `,`,
		`ByteSz:` + fmt.Sprintf("%v", this.ByteSz) + `,`,
		`InlineData:` + fmt.Sprintf("%v", this.InlineData) + `,`,
		`StreamURI:` + fmt.Sprintf("%v", this.StreamURI) + `,`,
		`BlobID:` + fmt.Sprintf("%v", this.BlobID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Err) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Err{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringArc(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= MsgOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqID", wireType)
			}
			m.ReqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID", wireType)
			}
			m.CellID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromID", wireType)
			}
			m.FromID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrID", wireType)
			}
			m.AttrID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SI", wireType)
			}
			m.SI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValType", wireType)
			}
			m.ValType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValType |= ValType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBuf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValBuf = append(m.ValBuf[:0], dAtA[iNdEx:postIndex]...)
			if m.ValBuf == nil {
				m.ValBuf = []byte{}
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValInt", wireType)
			}
			m.ValInt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValInt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= MsgFlags(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &Msg{}
			}
			if err := m.Next.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlanetEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlanetEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlanetEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochTID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochTID = append(m.EpochTID[:0], dAtA[iNdEx:postIndex]...)
			if m.EpochTID == nil {
				m.EpochTID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochEntries = append(m.EpochEntries, &Msg{})
			if err := m.EpochEntries[len(m.EpochEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommonName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomePlanetID", wireType)
			}
			m.HomePlanetID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HomePlanetID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserUID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserUID = append(m.UserUID[:0], dAtA[iNdEx:postIndex]...)
			if m.UserUID == nil {
				m.UserUID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Symbol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Symbol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Symbol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Defs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Defs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Defs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbols = append(m.Symbols, &Symbol{})
			if err := m.Symbols[len(m.Symbols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schemas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schemas = append(m.Schemas, &AttrSchema{})
			if err := m.Schemas[len(m.Schemas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttrSchema) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrSchema: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrSchema: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellModelURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CellModelURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaID", wireType)
			}
			m.SchemaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchemaID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attrs = append(m.Attrs, &AttrSpec{})
			if err := m.Attrs[len(m.Attrs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttrSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttrURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttrID", wireType)
			}
			m.AttrID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttrID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeriesType", wireType)
			}
			m.SeriesType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeriesType |= SeriesType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoundSI", wireType)
			}
			m.BoundSI = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BoundSI |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValTypeID", wireType)
			}
			m.ValTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValTypeID |= ValType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KwArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KwArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KwArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Val", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Val = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBuf", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValBuf = append(m.ValBuf[:0], dAtA[iNdEx:postIndex]...)
			if m.ValBuf == nil {
				m.ValBuf = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PinReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PinReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PinReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentReqID", wireType)
			}
			m.ParentReqID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentReqID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, &KwArg{})
			if err := m.Args[len(m.Args)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinCell", wireType)
			}
			m.PinCell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PinCell |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentSchema", wireType)
			}
			m.ContentSchema = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentSchema |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChildSchemas = append(m.ChildSchemas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowArc
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthArc
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthArc
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ChildSchemas) == 0 {
					m.ChildSchemas = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowArc
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChildSchemas = append(m.ChildSchemas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildSchemas", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttrRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttrRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttrRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SI_SeekTo", wireType)
			}
			m.SI_SeekTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SI_SeekTo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SI_StopAt", wireType)
			}
			m.SI_StopAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SI_StopAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SI_BatchLimit", wireType)
			}
			m.SI_BatchLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SI_BatchLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeoFix) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeoFix: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeoFix: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			m.Model = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Model |= GeoModel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lat = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lng", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lng = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alt", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Alt = float64(math.Float64frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AltROU", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AltROU = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PosROU", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PosROU = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Content) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Content: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Content: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentData = append(m.ContentData[:0], dAtA[iNdEx:postIndex]...)
			if m.ContentData == nil {
				m.ContentData = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentTypeID", wireType)
			}
			m.ContentTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentTypeID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinksCellID", wireType)
			}
			m.LinksCellID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LinksCellID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &GeoFix{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CryptoKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CryptoKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CryptoKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoKitID", wireType)
			}
			m.CryptoKitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CryptoKitID |= CryptoKitID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBytes = append(m.KeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyBytes == nil {
				m.KeyBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShapeURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShapeURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkinURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SkinURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TRS) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TRS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TRS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 41:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X1 = float64(math.Float64frombits(v))
		case 42:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X2", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X2 = float64(math.Float64frombits(v))
		case 43:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field X3", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.X3 = float64(math.Float64frombits(v))
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleMode", wireType)
			}
			m.ScaleMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScaleMode |= TRS_VisualScaleMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale1 = float32(math.Float32frombits(v))
		case 52:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale2 = float32(math.Float32frombits(v))
		case 53:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale3", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Scale3 = float32(math.Float32frombits(v))
		case 61:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate1 = float32(math.Float32frombits(v))
		case 62:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate2 = float32(math.Float32frombits(v))
		case 63:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotate3", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rotate3 = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeedParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeedParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeedParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIntervalMin", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UpdateIntervalMin = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateIntervalMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.UpdateIntervalMax = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteOfs", wireType)
			}
			m.ByteOfs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteOfs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteSz", wireType)
			}
			m.ByteSz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteSz |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineData = append(m.InlineData[:0], dAtA[iNdEx:postIndex]...)
			if m.InlineData == nil {
				m.InlineData = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamURI = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlobID", wireType)
			}
			m.BlobID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlobID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Err) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowArc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Err: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Err: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ErrCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowArc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthArc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthArc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipArc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthArc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipArc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowArc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowArc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthArc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupArc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthArc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthArc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowArc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupArc = fmt.Errorf("proto: unexpected end of group")
)
